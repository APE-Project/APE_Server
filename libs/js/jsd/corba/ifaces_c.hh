#ifndef _ifaces_c_hh
#define _ifaces_c_hh

/************************************************************************/
/*                                                                      */
/* This file is automatically generated by ORBeline IDL compiler        */
/* Do not modify this file.                                             */
/*                                                                      */
/* ORBeline (c) is copyrighted by PostModern Computing, Inc.            */
/*                                                                      */
/* The generated code conforms to OMG's IDL C++ mapping as              */
/* specified in OMG Document Number: 94-9-14.                           */
/*                                                                      */
/************************************************************************/

#include "corba.h"


struct Thing {
	CORBA::String_var	s;
	CORBA::Long	i;
	Thing& operator=(const Thing&);
};
NCostream& operator<<(NCostream&, const Thing& );
NCistream& operator>>(NCistream&, Thing& );
inline NCistream& operator>>(NCistream& _strm, Thing*& _obj) {
	_obj = new Thing;
	_strm >> *_obj;
	return _strm;
}

ostream& operator<<(ostream&, const Thing& );
inline istream& operator>>(istream& _strm, Thing& _obj) {
	NCistream _istrm(_strm);
	_istrm >> _obj;
	return _strm;
}
inline istream& operator>>(istream& _strm, Thing*& _obj) {
	_obj = new Thing;
	_strm >> *_obj;
	return _strm;
}


typedef Thing *Thing_ptr;
class Thing_var
{
    public:
	Thing_var() { _ptr = (Thing*)NULL;}
	Thing_var(Thing *ptr) {
		_ptr = ptr;
	}
	Thing_var(const Thing_var& var) {
		if (var._ptr)
			_ptr = new Thing(*var._ptr);
		else
			_ptr = (Thing *)NULL;
	}
	~Thing_var() {
		if (_ptr != (Thing *)NULL) delete _ptr;
	}
	Thing_var& operator=(Thing *ptr) {
		if (_ptr != (Thing *)NULL) delete _ptr;
		_ptr = ptr;
		return *this;
	}
	Thing_var& operator=(const Thing_var& var) {
		if (_ptr != (Thing *)NULL) delete _ptr;
		if (var._ptr)
			_ptr = new Thing(*var._ptr);
		else
			_ptr = (Thing *)NULL;
		return *this;
	}
	Thing *operator->() { return _ptr; }
	operator Thing *() const { return _ptr; }
#if defined(_HPCC_BUG)
	operator Thing *& () { return _ptr; }
#else
	operator Thing_ptr& () { return _ptr; }
#endif
	operator Thing& () { return *_ptr; }
	inline friend NCostream& operator<<(NCostream& strm,
			const Thing_var& var) {
		if (var._ptr == (Thing *)NULL) {
			throw CORBA::BAD_PARAM();
		}
		else
			strm << *var._ptr;
		return strm;
	}
	inline friend NCistream& operator>>(NCistream& strm,
			Thing_var& var) {
		if ( ! var._ptr)
			var._ptr = new Thing;
		strm >> *var._ptr;
		return strm;
	}
    private:
	Thing *_ptr;
};


class StringReciever;
typedef StringReciever *StringReciever_ptr;
typedef StringReciever_ptr StringRecieverRef;

#ifndef _StringReciever_var_
#define _StringReciever_var_
class StringReciever_var
{
    public:
	StringReciever_var();
	StringReciever_var(StringReciever_ptr);
	StringReciever_var(const StringReciever_var&);
	~StringReciever_var();
	StringReciever_var& operator=(StringReciever_ptr);
	operator StringReciever_ptr() const { return _ptr; }
#if defined(_HPCC_BUG)
	operator StringReciever *&() { return _ptr; }
#else
	operator StringReciever_ptr&() { return _ptr; }
#endif
	StringReciever_ptr operator->() const { return _ptr;}
	friend NCistream& operator>>(NCistream&, StringReciever_var&);
	friend NCostream& operator<<(NCostream&, const StringReciever_var&);
	friend istream& operator>>(istream&, StringReciever_var&);
	friend ostream& operator<<(ostream&, const StringReciever_var&);
    private:
	StringReciever_ptr	_ptr;
	void operator=(const StringReciever_var&) {}
};
#endif
class StringReciever: public virtual CORBA_Object
{
    private:
	static const CORBA::TypeInfo _class_info;
	StringReciever(const StringReciever&) {}
	void operator=(const StringReciever&){}
    public:
	static const CORBA::TypeInfo *_desc();
	virtual const CORBA::TypeInfo *_type_info() const;
	virtual void *_safe_narrow(const CORBA::TypeInfo& ) const;
	static CORBA::Object *_factory();
    protected:
	StringReciever(const char *obj_name = NULL) :CORBA_Object(obj_name, 1) {}
	StringReciever(NCistream& strm) :CORBA_Object(strm) {}
	virtual ~StringReciever() {}
    public:
	static StringReciever_ptr _duplicate(StringReciever_ptr obj) {
		if (obj ) obj->_ref();
		return obj;
	}
	static StringReciever_ptr _nil() { return (StringReciever_ptr)NULL;}
	static StringReciever_ptr _narrow(CORBA::Object *obj);
	static StringReciever_ptr _clone(StringReciever_ptr obj) {
		CORBA::Object_var obj_var(__clone(obj));

#if defined(_HPCC_BUG)
		return _narrow(obj_var.operator CORBA::Object_ptr());
#else
		return _narrow(obj_var);
#endif
	}
	static StringReciever_ptr _bind(const char *object_name = NULL,
		const char *host_name = NULL,
		const CORBA::BindOptions* opt = NULL); 

	virtual void recieveString(const char * arg0);
	
	virtual void bounce(CORBA::Long arg0);
	
	inline friend NCistream& operator>>(NCistream& strm, StringReciever_ptr& obj) {
		CORBA::Object_var _obj(obj);
		_obj = CORBA::Object::_read(strm, StringReciever::_desc());
		obj = StringReciever::_narrow(_obj);
		return strm;
	}
	inline friend ostream& operator<<(ostream& strm, const StringReciever_ptr obj) {
		strm << (CORBA::Object_ptr)obj;
		return strm;
	}
	inline friend istream& operator>>(istream& strm, StringReciever_ptr& obj) {
		NCistream istrm(strm);
		istrm >> obj;
		return strm;
	}
};



class TestInterface;
typedef TestInterface *TestInterface_ptr;
typedef TestInterface_ptr TestInterfaceRef;

#ifndef _TestInterface_var_
#define _TestInterface_var_
class TestInterface_var
{
    public:
	TestInterface_var();
	TestInterface_var(TestInterface_ptr);
	TestInterface_var(const TestInterface_var&);
	~TestInterface_var();
	TestInterface_var& operator=(TestInterface_ptr);
	operator TestInterface_ptr() const { return _ptr; }
#if defined(_HPCC_BUG)
	operator TestInterface *&() { return _ptr; }
#else
	operator TestInterface_ptr&() { return _ptr; }
#endif
	TestInterface_ptr operator->() const { return _ptr;}
	friend NCistream& operator>>(NCistream&, TestInterface_var&);
	friend NCostream& operator<<(NCostream&, const TestInterface_var&);
	friend istream& operator>>(istream&, TestInterface_var&);
	friend ostream& operator<<(ostream&, const TestInterface_var&);
    private:
	TestInterface_ptr	_ptr;
	void operator=(const TestInterface_var&) {}
};
#endif
class TestInterface: public virtual CORBA_Object
{
    private:
	static const CORBA::TypeInfo _class_info;
	TestInterface(const TestInterface&) {}
	void operator=(const TestInterface&){}
    public:
	static const CORBA::TypeInfo *_desc();
	virtual const CORBA::TypeInfo *_type_info() const;
	virtual void *_safe_narrow(const CORBA::TypeInfo& ) const;
	static CORBA::Object *_factory();
    protected:
	TestInterface(const char *obj_name = NULL) :CORBA_Object(obj_name, 1) {}
	TestInterface(NCistream& strm) :CORBA_Object(strm) {}
	virtual ~TestInterface() {}
    public:
	static TestInterface_ptr _duplicate(TestInterface_ptr obj) {
		if (obj ) obj->_ref();
		return obj;
	}
	static TestInterface_ptr _nil() { return (TestInterface_ptr)NULL;}
	static TestInterface_ptr _narrow(CORBA::Object *obj);
	static TestInterface_ptr _clone(TestInterface_ptr obj) {
		CORBA::Object_var obj_var(__clone(obj));

#if defined(_HPCC_BUG)
		return _narrow(obj_var.operator CORBA::Object_ptr());
#else
		return _narrow(obj_var);
#endif
	}
	static TestInterface_ptr _bind(const char *object_name = NULL,
		const char *host_name = NULL,
		const CORBA::BindOptions* opt = NULL); 

	virtual char * getFirstAppInList();
	
	virtual void getAppNames(StringReciever_ptr arg0);
	
	
	class sequence_of_Thing
	{
	    public:
		static Thing *allocbuf(CORBA::ULong nelems);
	static void freebuf(Thing *data);
		sequence_of_Thing(CORBA::ULong max=0);
		sequence_of_Thing(CORBA::ULong max,
			CORBA::ULong length,
			Thing *data,
			CORBA::Boolean release=0);
		sequence_of_Thing(const sequence_of_Thing&);
		~sequence_of_Thing();
		sequence_of_Thing& operator=(const sequence_of_Thing&);
		CORBA::ULong maximum() const { return _num_allocated; }
		void length(CORBA::ULong len);
		CORBA::ULong length() const { return _count;}
		Thing& operator[](CORBA::ULong index);
		const Thing& operator[](CORBA::ULong index) const;
		friend NCostream& operator<<(NCostream&, const sequence_of_Thing&);
		inline friend NCostream& operator<<(NCostream& strm, const sequence_of_Thing *obj) {
			if ( obj == (sequence_of_Thing*)NULL)
				throw CORBA::BAD_PARAM();
			else
				strm << *obj;
			return strm;
		}
		friend NCistream& operator>>(NCistream&, sequence_of_Thing&);
		inline friend NCistream& operator>>(NCistream& strm, sequence_of_Thing*& obj) {
			obj = new sequence_of_Thing;
			strm >> *obj;
			return strm;
		}
		friend ostream& operator<<(ostream&, const sequence_of_Thing&);
		inline friend istream& operator>>(istream& strm, sequence_of_Thing& obj) {
			NCistream istrm(strm);
			istrm >> obj;
			return strm;
		}
		inline friend istream& operator>>(istream& strm, sequence_of_Thing *& obj) {
			NCistream istrm(strm);
			istrm >> obj;
			return strm;
		}
		static sequence_of_Thing *_duplicate(sequence_of_Thing* ptr) {
			if (ptr) ptr->_ref_count++;
			return ptr;
		}
		static void _release(sequence_of_Thing *ptr) {
			if (ptr && ( --ptr->_ref_count == 0) )
				delete ptr;
		}
	    private:
		Thing	*_contents;
		CORBA::ULong	_count;
		CORBA::ULong	_num_allocated;
		CORBA::Boolean	_release_flag;
		CORBA::Long	_ref_count;
	};
	
	
	typedef sequence_of_Thing *sequence_of_Thing_ptr;
	class sequence_of_Thing_var
	{
	    public:
		sequence_of_Thing_var() : _ptr((sequence_of_Thing *)NULL) {}
		sequence_of_Thing_var(sequence_of_Thing *ptr) :_ptr(ptr) {}
		sequence_of_Thing_var(const sequence_of_Thing_var& var) :
			_ptr(sequence_of_Thing::_duplicate((sequence_of_Thing *)var)){}
		~sequence_of_Thing_var() { sequence_of_Thing::_release(_ptr); }
		sequence_of_Thing_var& operator=(sequence_of_Thing *ptr) {
			if (_ptr != ptr) {
				sequence_of_Thing::_release(_ptr);
				_ptr = ptr;
			}
			return *this;
		}
		sequence_of_Thing_var& operator=(const sequence_of_Thing_var& var) {
			sequence_of_Thing::_release(_ptr);
			_ptr = sequence_of_Thing::_duplicate((sequence_of_Thing *)var);
			return *this;
		}
		sequence_of_Thing *operator->() { return _ptr; }
		Thing& operator[](CORBA::ULong index) {
			return _ptr->operator[](index);
		}
		const Thing& operator[](CORBA::ULong index) const {
			return _ptr->operator[](index);
		}
		operator sequence_of_Thing *() const { return _ptr; }
#if defined(_HPCC_BUG)
		operator sequence_of_Thing* &() { return _ptr; }
#else
		operator sequence_of_Thing_ptr& () { return _ptr; }
#endif
		operator const sequence_of_Thing& () const { return *_ptr; }
		operator sequence_of_Thing& () { return *_ptr; }
		inline friend NCostream& operator<<(NCostream& strm, 
				const sequence_of_Thing_var& var) {
			if ( var._ptr == (sequence_of_Thing *)NULL) {
				throw CORBA::BAD_PARAM();
			}
			else
				strm << *var._ptr;
			return strm;
		}
		inline friend NCistream& operator>>(NCistream& strm,
				sequence_of_Thing_var& var) {
			if ( var._ptr == (sequence_of_Thing *)NULL )
				var._ptr = new sequence_of_Thing;
			strm >> *var._ptr;
			return strm;
		}
	    private:
		sequence_of_Thing *_ptr;
	};
	
	
	
	
	virtual sequence_of_Thing * getThings();
	
	virtual void callBounce(StringReciever_ptr arg0,
			CORBA::Long arg1);
	
	inline friend NCistream& operator>>(NCistream& strm, TestInterface_ptr& obj) {
		CORBA::Object_var _obj(obj);
		_obj = CORBA::Object::_read(strm, TestInterface::_desc());
		obj = TestInterface::_narrow(_obj);
		return strm;
	}
	inline friend ostream& operator<<(ostream& strm, const TestInterface_ptr obj) {
		strm << (CORBA::Object_ptr)obj;
		return strm;
	}
	inline friend istream& operator>>(istream& strm, TestInterface_ptr& obj) {
		NCistream istrm(strm);
		istrm >> obj;
		return strm;
	}
};



class ISourceTextProvider;
typedef ISourceTextProvider *ISourceTextProvider_ptr;
typedef ISourceTextProvider_ptr ISourceTextProviderRef;

#ifndef _ISourceTextProvider_var_
#define _ISourceTextProvider_var_
class ISourceTextProvider_var
{
    public:
	ISourceTextProvider_var();
	ISourceTextProvider_var(ISourceTextProvider_ptr);
	ISourceTextProvider_var(const ISourceTextProvider_var&);
	~ISourceTextProvider_var();
	ISourceTextProvider_var& operator=(ISourceTextProvider_ptr);
	operator ISourceTextProvider_ptr() const { return _ptr; }
#if defined(_HPCC_BUG)
	operator ISourceTextProvider *&() { return _ptr; }
#else
	operator ISourceTextProvider_ptr&() { return _ptr; }
#endif
	ISourceTextProvider_ptr operator->() const { return _ptr;}
	friend NCistream& operator>>(NCistream&, ISourceTextProvider_var&);
	friend NCostream& operator<<(NCostream&, const ISourceTextProvider_var&);
	friend istream& operator>>(istream&, ISourceTextProvider_var&);
	friend ostream& operator<<(ostream&, const ISourceTextProvider_var&);
    private:
	ISourceTextProvider_ptr	_ptr;
	void operator=(const ISourceTextProvider_var&) {}
};
#endif
class ISourceTextProvider: public virtual CORBA_Object
{
    private:
	static const CORBA::TypeInfo _class_info;
	ISourceTextProvider(const ISourceTextProvider&) {}
	void operator=(const ISourceTextProvider&){}
    public:
	static const CORBA::TypeInfo *_desc();
	virtual const CORBA::TypeInfo *_type_info() const;
	virtual void *_safe_narrow(const CORBA::TypeInfo& ) const;
	static CORBA::Object *_factory();
    protected:
	ISourceTextProvider(const char *obj_name = NULL) :CORBA_Object(obj_name, 1) {}
	ISourceTextProvider(NCistream& strm) :CORBA_Object(strm) {}
	virtual ~ISourceTextProvider() {}
    public:
	static ISourceTextProvider_ptr _duplicate(ISourceTextProvider_ptr obj) {
		if (obj ) obj->_ref();
		return obj;
	}
	static ISourceTextProvider_ptr _nil() { return (ISourceTextProvider_ptr)NULL;}
	static ISourceTextProvider_ptr _narrow(CORBA::Object *obj);
	static ISourceTextProvider_ptr _clone(ISourceTextProvider_ptr obj) {
		CORBA::Object_var obj_var(__clone(obj));

#if defined(_HPCC_BUG)
		return _narrow(obj_var.operator CORBA::Object_ptr());
#else
		return _narrow(obj_var);
#endif
	}
	static ISourceTextProvider_ptr _bind(const char *object_name = NULL,
		const char *host_name = NULL,
		const CORBA::BindOptions* opt = NULL); 

	
	class sequence_of_string
	{
	    public:
		static char **allocbuf(CORBA::ULong nelems) {
			char **ret= new char *[nelems];
			memset(ret, 0, size_t(nelems) * sizeof(char *));
			return ret;
		}
		static void freebuf(char **data) {
			if (data) delete[] data;
		}
		static void freebuf_elems(char **data, CORBA::ULong nelem) {
			if (data) {
				for (CORBA::ULong i=0; i< nelem; i++)
					CORBA::string_free(data[i]);
				delete[] data;
			}
		}
		class Sequence_string
		{
			friend sequence_of_string;
		    private:
			CORBA::Boolean	_rel_flag;
			char **		_ptr;
			void release() {if (_rel_flag) CORBA::string_free(*_ptr);}
			Sequence_string& operator=(const Sequence_string& ) {
				return *this;
			}
		    public:
			Sequence_string(char **ptr, CORBA::Boolean rel_flag) :_ptr(ptr), _rel_flag(rel_flag) {}
			Sequence_string(const Sequence_string& seq) {
				_ptr = seq._ptr; _rel_flag = seq._rel_flag;
			}
			~Sequence_string() {}
			Sequence_string& operator=(char *p) {
				if ( *_ptr != p) {
					release();
					*_ptr = p;
				}
				return *this;
			}
			Sequence_string& operator=(const char *p) {
				if ( *_ptr != p) {
					release();
					*_ptr = CORBA::string_alloc(strlen(p));
					strcpy(*_ptr, p);
				}
				return *this;
			}
			operator const char *() const { return *_ptr; }
			operator char *() { return *_ptr; }
			char& operator[](CORBA::ULong index) {return *_ptr[index];}
			char operator[](CORBA::ULong index) const {return *_ptr[index];}
		};
		sequence_of_string(CORBA::ULong max=0);
		sequence_of_string(CORBA::ULong max,
				CORBA::ULong length,
				char **data,
				CORBA::Boolean release=0);
		sequence_of_string(const sequence_of_string&);
		~sequence_of_string();
		sequence_of_string& operator=(const sequence_of_string&);
		CORBA::ULong maximum() const { return _num_allocated;}
		void length(CORBA::ULong);
		CORBA::ULong length() const { return _count; }
		Sequence_string operator[](CORBA::ULong index) {
			if (index >= _count)
				throw CORBA::BAD_PARAM();
			return Sequence_string(&_buffer[index], _rel_flag);
		}
		const char *operator[](CORBA::ULong index) const {
			if (index >= _count)
				throw CORBA::BAD_PARAM();
			return _buffer[index];
		}
		friend NCostream& operator<<(NCostream& strm, const sequence_of_string&);
		inline friend NCostream& operator<<(NCostream& strm, const sequence_of_string *obj) {
			if ( obj == (sequence_of_string*)NULL)
				throw CORBA::BAD_PARAM();
			else
				strm << *obj;
			return strm;
		}
		friend NCistream& operator>>(NCistream& strm, sequence_of_string&);
		inline friend NCistream& operator>>(NCistream& strm, sequence_of_string*& obj) {
		obj = new sequence_of_string;
			strm >> *obj;
			return strm;
		}
		friend ostream& operator<<(ostream& strm, const sequence_of_string&);
		inline friend istream& operator>>(istream& strm, sequence_of_string& obj) {
			NCistream istrm(strm);
			istrm >> obj;
			return strm;
		}
		inline friend istream& operator>>(istream& strm, sequence_of_string *& obj) {
			NCistream istrm(strm);
			istrm >> obj;
			return strm;
		}
		static sequence_of_string *_duplicate(sequence_of_string* ptr) {
			if (ptr) ptr->_ref_count++;
			return ptr;
		}
		static void _release(sequence_of_string *ptr) {
			if (ptr && ( --ptr->_ref_count == 0) )
				delete ptr;
		}
	    private:
		CORBA::ULong		_count;
		char			**_buffer;
		CORBA::Boolean		_rel_flag;
		CORBA::ULong		_num_allocated;
		CORBA::Long		_ref_count;
		void release_on_copy(CORBA::Boolean val) {_rel_flag = val;}
		CORBA::Boolean release_on_copy() const {return _rel_flag;}
	};
	
	typedef sequence_of_string *sequence_of_string_ptr;
	class sequence_of_string_var
	{
	    public:
		sequence_of_string_var() { _ptr = (sequence_of_string *)NULL; }
		sequence_of_string_var(sequence_of_string *ptr) {
			_ptr = ptr;
		}
		sequence_of_string_var(const sequence_of_string_var& var) {
			_ptr = sequence_of_string::_duplicate((sequence_of_string *)var);
		}
		~sequence_of_string_var() { sequence_of_string::_release(_ptr); }
		sequence_of_string_var& operator=(sequence_of_string *ptr) {
			if (_ptr != ptr) {
				sequence_of_string::_release(_ptr);
				_ptr = ptr;
			}
			return *this;
		}
		sequence_of_string_var& operator=(const sequence_of_string_var& var) {
			sequence_of_string::_release(_ptr);
			_ptr = sequence_of_string::_duplicate((sequence_of_string *)var);
			return *this;
		}
		sequence_of_string *operator->() { return _ptr; }
		sequence_of_string::Sequence_string operator[](CORBA::ULong index) {
			return _ptr->operator[](index);
		}
		const char * operator[](CORBA::ULong index) const {
			return _ptr->operator[](index);
		}
		operator sequence_of_string *() const { return _ptr; }
#if defined(_HPCC_BUG)
		operator sequence_of_string* &() { return _ptr; }
#else
		operator sequence_of_string_ptr& () { return _ptr; }
#endif
		operator const sequence_of_string& () const { return *_ptr; }
		operator sequence_of_string &() { return *_ptr; }
		inline friend NCostream& operator<<(NCostream& strm, 
				const sequence_of_string_var& var) {
			if ( var._ptr == (sequence_of_string *)NULL) {
				throw CORBA::BAD_PARAM();
			}
			else
				strm << *var._ptr;
			return strm;
		}
		inline friend NCistream& operator>>(NCistream& strm,
				sequence_of_string_var& var) {
			if ( var._ptr == (sequence_of_string *)NULL )
				var._ptr = new sequence_of_string;
			strm >> *var._ptr;
			return strm;
		}
	    private:
		sequence_of_string *_ptr;
	};
	
	
	
	
	virtual sequence_of_string * getAllPages();
	
	virtual void refreshAllPages();
	
	virtual CORBA::Boolean hasPage(const char * arg0);
	
	virtual CORBA::Boolean loadPage(const char * arg0);
	
	virtual void refreshPage(const char * arg0);
	
	virtual char * getPageText(const char * arg0);
	
	virtual CORBA::Long getPageStatus(const char * arg0);
	
	virtual CORBA::Long getPageAlterCount(const char * arg0);
	
	inline friend NCistream& operator>>(NCistream& strm, ISourceTextProvider_ptr& obj) {
		CORBA::Object_var _obj(obj);
		_obj = CORBA::Object::_read(strm, ISourceTextProvider::_desc());
		obj = ISourceTextProvider::_narrow(_obj);
		return strm;
	}
	inline friend ostream& operator<<(ostream& strm, const ISourceTextProvider_ptr obj) {
		strm << (CORBA::Object_ptr)obj;
		return strm;
	}
	inline friend istream& operator>>(istream& strm, ISourceTextProvider_ptr& obj) {
		NCistream istrm(strm);
		istrm >> obj;
		return strm;
	}
};


struct IScriptSection {
	CORBA::Long	base;
	CORBA::Long	extent;
};
NCostream& operator<<(NCostream&, const IScriptSection& );
NCistream& operator>>(NCistream&, IScriptSection& );

ostream& operator<<(ostream&, const IScriptSection& );
inline istream& operator>>(istream& _strm, IScriptSection& _obj) {
	NCistream _istrm(_strm);
	_istrm >> _obj;
	return _strm;
}


typedef IScriptSection *IScriptSection_ptr;
class IScriptSection_var
{
    public:
	IScriptSection_var() { _ptr = (IScriptSection*)NULL;}
	IScriptSection_var(IScriptSection *ptr) {
		_ptr = ptr;
	}
	IScriptSection_var(const IScriptSection_var& var) {
		if (var._ptr)
			_ptr = new IScriptSection(*var._ptr);
		else
			_ptr = (IScriptSection *)NULL;
	}
	~IScriptSection_var() {
		if (_ptr != (IScriptSection *)NULL) delete _ptr;
	}
	IScriptSection_var& operator=(IScriptSection *ptr) {
		if (_ptr != (IScriptSection *)NULL) delete _ptr;
		_ptr = ptr;
		return *this;
	}
	IScriptSection_var& operator=(const IScriptSection_var& var) {
		if (_ptr != (IScriptSection *)NULL) delete _ptr;
		if (var._ptr)
			_ptr = new IScriptSection(*var._ptr);
		else
			_ptr = (IScriptSection *)NULL;
		return *this;
	}
	IScriptSection *operator->() { return _ptr; }
	operator IScriptSection () const { return *_ptr; }
	operator IScriptSection& () { return *_ptr; }
	inline friend NCostream& operator<<(NCostream& strm,
			const IScriptSection_var& var) {
		if (var._ptr == (IScriptSection *)NULL) {
			throw CORBA::BAD_PARAM();
		}
		else
			strm << *var._ptr;
		return strm;
	}
	inline friend NCistream& operator>>(NCistream& strm,
			IScriptSection_var& var) {
		if ( ! var._ptr)
			var._ptr = new IScriptSection;
		strm >> *var._ptr;
		return strm;
	}
    private:
	IScriptSection *_ptr;
};


class sequence_of_IScriptSection
{
    public:
	static IScriptSection *allocbuf(CORBA::ULong nelems);
	static void freebuf(IScriptSection *data);
	sequence_of_IScriptSection(CORBA::ULong max=0);
	sequence_of_IScriptSection(CORBA::ULong max,
		CORBA::ULong length,
		IScriptSection *data,
		CORBA::Boolean release=0);
	sequence_of_IScriptSection(const sequence_of_IScriptSection&);
	~sequence_of_IScriptSection();
	sequence_of_IScriptSection& operator=(const sequence_of_IScriptSection&);
	CORBA::ULong maximum() const { return _num_allocated; }
	void length(CORBA::ULong len);
	CORBA::ULong length() const { return _count;}
	IScriptSection& operator[](CORBA::ULong index);
	const IScriptSection& operator[](CORBA::ULong index) const;
	friend NCostream& operator<<(NCostream&, const sequence_of_IScriptSection&);
	inline friend NCostream& operator<<(NCostream& strm, const sequence_of_IScriptSection *obj) {
		if ( obj == (sequence_of_IScriptSection*)NULL)
			throw CORBA::BAD_PARAM();
		else
			strm << *obj;
		return strm;
	}
	friend NCistream& operator>>(NCistream&, sequence_of_IScriptSection&);
	inline friend NCistream& operator>>(NCistream& strm, sequence_of_IScriptSection*& obj) {
		obj = new sequence_of_IScriptSection;
		strm >> *obj;
		return strm;
	}
	friend ostream& operator<<(ostream&, const sequence_of_IScriptSection&);
	inline friend istream& operator>>(istream& strm, sequence_of_IScriptSection& obj) {
		NCistream istrm(strm);
		istrm >> obj;
		return strm;
	}
	inline friend istream& operator>>(istream& strm, sequence_of_IScriptSection *& obj) {
		NCistream istrm(strm);
		istrm >> obj;
		return strm;
	}
	static sequence_of_IScriptSection *_duplicate(sequence_of_IScriptSection* ptr) {
		if (ptr) ptr->_ref_count++;
		return ptr;
	}
	static void _release(sequence_of_IScriptSection *ptr) {
		if (ptr && ( --ptr->_ref_count == 0) )
			delete ptr;
	}
    private:
	IScriptSection	*_contents;
	CORBA::ULong	_count;
	CORBA::ULong	_num_allocated;
	CORBA::Boolean	_release_flag;
	CORBA::Long	_ref_count;
};


typedef sequence_of_IScriptSection *sequence_of_IScriptSection_ptr;
class sequence_of_IScriptSection_var
{
    public:
	sequence_of_IScriptSection_var() : _ptr((sequence_of_IScriptSection *)NULL) {}
	sequence_of_IScriptSection_var(sequence_of_IScriptSection *ptr) :_ptr(ptr) {}
	sequence_of_IScriptSection_var(const sequence_of_IScriptSection_var& var) :
		_ptr(sequence_of_IScriptSection::_duplicate((sequence_of_IScriptSection *)var)){}
	~sequence_of_IScriptSection_var() { sequence_of_IScriptSection::_release(_ptr); }
	sequence_of_IScriptSection_var& operator=(sequence_of_IScriptSection *ptr) {
		if (_ptr != ptr) {
			sequence_of_IScriptSection::_release(_ptr);
			_ptr = ptr;
		}
		return *this;
	}
	sequence_of_IScriptSection_var& operator=(const sequence_of_IScriptSection_var& var) {
		sequence_of_IScriptSection::_release(_ptr);
		_ptr = sequence_of_IScriptSection::_duplicate((sequence_of_IScriptSection *)var);
		return *this;
	}
	sequence_of_IScriptSection *operator->() { return _ptr; }
	IScriptSection& operator[](CORBA::ULong index) {
		return _ptr->operator[](index);
	}
	const IScriptSection& operator[](CORBA::ULong index) const {
		return _ptr->operator[](index);
	}
	operator sequence_of_IScriptSection *() const { return _ptr; }
#if defined(_HPCC_BUG)
	operator sequence_of_IScriptSection* &() { return _ptr; }
#else
	operator sequence_of_IScriptSection_ptr& () { return _ptr; }
#endif
	operator const sequence_of_IScriptSection& () const { return *_ptr; }
	operator sequence_of_IScriptSection& () { return *_ptr; }
	inline friend NCostream& operator<<(NCostream& strm, 
			const sequence_of_IScriptSection_var& var) {
		if ( var._ptr == (sequence_of_IScriptSection *)NULL) {
			throw CORBA::BAD_PARAM();
		}
		else
			strm << *var._ptr;
		return strm;
	}
	inline friend NCistream& operator>>(NCistream& strm,
			sequence_of_IScriptSection_var& var) {
		if ( var._ptr == (sequence_of_IScriptSection *)NULL )
			var._ptr = new sequence_of_IScriptSection;
		strm >> *var._ptr;
		return strm;
	}
    private:
	sequence_of_IScriptSection *_ptr;
};



struct IScript {
	CORBA::String_var	url;
	CORBA::String_var	funname;
	CORBA::Long	base;
	CORBA::Long	extent;
	CORBA::Long	jsdscript;
	sequence_of_IScriptSection	sections;
	IScript& operator=(const IScript&);
};
NCostream& operator<<(NCostream&, const IScript& );
NCistream& operator>>(NCistream&, IScript& );
inline NCistream& operator>>(NCistream& _strm, IScript*& _obj) {
	_obj = new IScript;
	_strm >> *_obj;
	return _strm;
}

ostream& operator<<(ostream&, const IScript& );
inline istream& operator>>(istream& _strm, IScript& _obj) {
	NCistream _istrm(_strm);
	_istrm >> _obj;
	return _strm;
}
inline istream& operator>>(istream& _strm, IScript*& _obj) {
	_obj = new IScript;
	_strm >> *_obj;
	return _strm;
}


typedef IScript *IScript_ptr;
class IScript_var
{
    public:
	IScript_var() { _ptr = (IScript*)NULL;}
	IScript_var(IScript *ptr) {
		_ptr = ptr;
	}
	IScript_var(const IScript_var& var) {
		if (var._ptr)
			_ptr = new IScript(*var._ptr);
		else
			_ptr = (IScript *)NULL;
	}
	~IScript_var() {
		if (_ptr != (IScript *)NULL) delete _ptr;
	}
	IScript_var& operator=(IScript *ptr) {
		if (_ptr != (IScript *)NULL) delete _ptr;
		_ptr = ptr;
		return *this;
	}
	IScript_var& operator=(const IScript_var& var) {
		if (_ptr != (IScript *)NULL) delete _ptr;
		if (var._ptr)
			_ptr = new IScript(*var._ptr);
		else
			_ptr = (IScript *)NULL;
		return *this;
	}
	IScript *operator->() { return _ptr; }
	operator IScript *() const { return _ptr; }
#if defined(_HPCC_BUG)
	operator IScript *& () { return _ptr; }
#else
	operator IScript_ptr& () { return _ptr; }
#endif
	operator IScript& () { return *_ptr; }
	inline friend NCostream& operator<<(NCostream& strm,
			const IScript_var& var) {
		if (var._ptr == (IScript *)NULL) {
			throw CORBA::BAD_PARAM();
		}
		else
			strm << *var._ptr;
		return strm;
	}
	inline friend NCistream& operator>>(NCistream& strm,
			IScript_var& var) {
		if ( ! var._ptr)
			var._ptr = new IScript;
		strm >> *var._ptr;
		return strm;
	}
    private:
	IScript *_ptr;
};

struct IJSPC {
	IScript	script;
	CORBA::Long	offset;
	IJSPC& operator=(const IJSPC&);
};
NCostream& operator<<(NCostream&, const IJSPC& );
NCistream& operator>>(NCistream&, IJSPC& );
inline NCistream& operator>>(NCistream& _strm, IJSPC*& _obj) {
	_obj = new IJSPC;
	_strm >> *_obj;
	return _strm;
}

ostream& operator<<(ostream&, const IJSPC& );
inline istream& operator>>(istream& _strm, IJSPC& _obj) {
	NCistream _istrm(_strm);
	_istrm >> _obj;
	return _strm;
}
inline istream& operator>>(istream& _strm, IJSPC*& _obj) {
	_obj = new IJSPC;
	_strm >> *_obj;
	return _strm;
}


typedef IJSPC *IJSPC_ptr;
class IJSPC_var
{
    public:
	IJSPC_var() { _ptr = (IJSPC*)NULL;}
	IJSPC_var(IJSPC *ptr) {
		_ptr = ptr;
	}
	IJSPC_var(const IJSPC_var& var) {
		if (var._ptr)
			_ptr = new IJSPC(*var._ptr);
		else
			_ptr = (IJSPC *)NULL;
	}
	~IJSPC_var() {
		if (_ptr != (IJSPC *)NULL) delete _ptr;
	}
	IJSPC_var& operator=(IJSPC *ptr) {
		if (_ptr != (IJSPC *)NULL) delete _ptr;
		_ptr = ptr;
		return *this;
	}
	IJSPC_var& operator=(const IJSPC_var& var) {
		if (_ptr != (IJSPC *)NULL) delete _ptr;
		if (var._ptr)
			_ptr = new IJSPC(*var._ptr);
		else
			_ptr = (IJSPC *)NULL;
		return *this;
	}
	IJSPC *operator->() { return _ptr; }
	operator IJSPC *() const { return _ptr; }
#if defined(_HPCC_BUG)
	operator IJSPC *& () { return _ptr; }
#else
	operator IJSPC_ptr& () { return _ptr; }
#endif
	operator IJSPC& () { return *_ptr; }
	inline friend NCostream& operator<<(NCostream& strm,
			const IJSPC_var& var) {
		if (var._ptr == (IJSPC *)NULL) {
			throw CORBA::BAD_PARAM();
		}
		else
			strm << *var._ptr;
		return strm;
	}
	inline friend NCistream& operator>>(NCistream& strm,
			IJSPC_var& var) {
		if ( ! var._ptr)
			var._ptr = new IJSPC;
		strm >> *var._ptr;
		return strm;
	}
    private:
	IJSPC *_ptr;
};

struct IJSSourceLocation {
	CORBA::Long	line;
	IJSPC	pc;
	IJSSourceLocation& operator=(const IJSSourceLocation&);
};
NCostream& operator<<(NCostream&, const IJSSourceLocation& );
NCistream& operator>>(NCistream&, IJSSourceLocation& );
inline NCistream& operator>>(NCistream& _strm, IJSSourceLocation*& _obj) {
	_obj = new IJSSourceLocation;
	_strm >> *_obj;
	return _strm;
}

ostream& operator<<(ostream&, const IJSSourceLocation& );
inline istream& operator>>(istream& _strm, IJSSourceLocation& _obj) {
	NCistream _istrm(_strm);
	_istrm >> _obj;
	return _strm;
}
inline istream& operator>>(istream& _strm, IJSSourceLocation*& _obj) {
	_obj = new IJSSourceLocation;
	_strm >> *_obj;
	return _strm;
}


typedef IJSSourceLocation *IJSSourceLocation_ptr;
class IJSSourceLocation_var
{
    public:
	IJSSourceLocation_var() { _ptr = (IJSSourceLocation*)NULL;}
	IJSSourceLocation_var(IJSSourceLocation *ptr) {
		_ptr = ptr;
	}
	IJSSourceLocation_var(const IJSSourceLocation_var& var) {
		if (var._ptr)
			_ptr = new IJSSourceLocation(*var._ptr);
		else
			_ptr = (IJSSourceLocation *)NULL;
	}
	~IJSSourceLocation_var() {
		if (_ptr != (IJSSourceLocation *)NULL) delete _ptr;
	}
	IJSSourceLocation_var& operator=(IJSSourceLocation *ptr) {
		if (_ptr != (IJSSourceLocation *)NULL) delete _ptr;
		_ptr = ptr;
		return *this;
	}
	IJSSourceLocation_var& operator=(const IJSSourceLocation_var& var) {
		if (_ptr != (IJSSourceLocation *)NULL) delete _ptr;
		if (var._ptr)
			_ptr = new IJSSourceLocation(*var._ptr);
		else
			_ptr = (IJSSourceLocation *)NULL;
		return *this;
	}
	IJSSourceLocation *operator->() { return _ptr; }
	operator IJSSourceLocation *() const { return _ptr; }
#if defined(_HPCC_BUG)
	operator IJSSourceLocation *& () { return _ptr; }
#else
	operator IJSSourceLocation_ptr& () { return _ptr; }
#endif
	operator IJSSourceLocation& () { return *_ptr; }
	inline friend NCostream& operator<<(NCostream& strm,
			const IJSSourceLocation_var& var) {
		if (var._ptr == (IJSSourceLocation *)NULL) {
			throw CORBA::BAD_PARAM();
		}
		else
			strm << *var._ptr;
		return strm;
	}
	inline friend NCistream& operator>>(NCistream& strm,
			IJSSourceLocation_var& var) {
		if ( ! var._ptr)
			var._ptr = new IJSSourceLocation;
		strm >> *var._ptr;
		return strm;
	}
    private:
	IJSSourceLocation *_ptr;
};


class IJSErrorReporter;
typedef IJSErrorReporter *IJSErrorReporter_ptr;
typedef IJSErrorReporter_ptr IJSErrorReporterRef;

#ifndef _IJSErrorReporter_var_
#define _IJSErrorReporter_var_
class IJSErrorReporter_var
{
    public:
	IJSErrorReporter_var();
	IJSErrorReporter_var(IJSErrorReporter_ptr);
	IJSErrorReporter_var(const IJSErrorReporter_var&);
	~IJSErrorReporter_var();
	IJSErrorReporter_var& operator=(IJSErrorReporter_ptr);
	operator IJSErrorReporter_ptr() const { return _ptr; }
#if defined(_HPCC_BUG)
	operator IJSErrorReporter *&() { return _ptr; }
#else
	operator IJSErrorReporter_ptr&() { return _ptr; }
#endif
	IJSErrorReporter_ptr operator->() const { return _ptr;}
	friend NCistream& operator>>(NCistream&, IJSErrorReporter_var&);
	friend NCostream& operator<<(NCostream&, const IJSErrorReporter_var&);
	friend istream& operator>>(istream&, IJSErrorReporter_var&);
	friend ostream& operator<<(ostream&, const IJSErrorReporter_var&);
    private:
	IJSErrorReporter_ptr	_ptr;
	void operator=(const IJSErrorReporter_var&) {}
};
#endif
class IJSErrorReporter: public virtual CORBA_Object
{
    private:
	static const CORBA::TypeInfo _class_info;
	IJSErrorReporter(const IJSErrorReporter&) {}
	void operator=(const IJSErrorReporter&){}
    public:
	static const CORBA::TypeInfo *_desc();
	virtual const CORBA::TypeInfo *_type_info() const;
	virtual void *_safe_narrow(const CORBA::TypeInfo& ) const;
	static CORBA::Object *_factory();
    protected:
	IJSErrorReporter(const char *obj_name = NULL) :CORBA_Object(obj_name, 1) {}
	IJSErrorReporter(NCistream& strm) :CORBA_Object(strm) {}
	virtual ~IJSErrorReporter() {}
    public:
	static IJSErrorReporter_ptr _duplicate(IJSErrorReporter_ptr obj) {
		if (obj ) obj->_ref();
		return obj;
	}
	static IJSErrorReporter_ptr _nil() { return (IJSErrorReporter_ptr)NULL;}
	static IJSErrorReporter_ptr _narrow(CORBA::Object *obj);
	static IJSErrorReporter_ptr _clone(IJSErrorReporter_ptr obj) {
		CORBA::Object_var obj_var(__clone(obj));

#if defined(_HPCC_BUG)
		return _narrow(obj_var.operator CORBA::Object_ptr());
#else
		return _narrow(obj_var);
#endif
	}
	static IJSErrorReporter_ptr _bind(const char *object_name = NULL,
		const char *host_name = NULL,
		const CORBA::BindOptions* opt = NULL); 

	virtual CORBA::Long reportError(const char * arg0,
			const char * arg1,
			CORBA::Long arg2,
			const char * arg3,
			CORBA::Long arg4);
	
	inline friend NCistream& operator>>(NCistream& strm, IJSErrorReporter_ptr& obj) {
		CORBA::Object_var _obj(obj);
		_obj = CORBA::Object::_read(strm, IJSErrorReporter::_desc());
		obj = IJSErrorReporter::_narrow(_obj);
		return strm;
	}
	inline friend ostream& operator<<(ostream& strm, const IJSErrorReporter_ptr obj) {
		strm << (CORBA::Object_ptr)obj;
		return strm;
	}
	inline friend istream& operator>>(istream& strm, IJSErrorReporter_ptr& obj) {
		NCistream istrm(strm);
		istrm >> obj;
		return strm;
	}
};



class IScriptHook;
typedef IScriptHook *IScriptHook_ptr;
typedef IScriptHook_ptr IScriptHookRef;

#ifndef _IScriptHook_var_
#define _IScriptHook_var_
class IScriptHook_var
{
    public:
	IScriptHook_var();
	IScriptHook_var(IScriptHook_ptr);
	IScriptHook_var(const IScriptHook_var&);
	~IScriptHook_var();
	IScriptHook_var& operator=(IScriptHook_ptr);
	operator IScriptHook_ptr() const { return _ptr; }
#if defined(_HPCC_BUG)
	operator IScriptHook *&() { return _ptr; }
#else
	operator IScriptHook_ptr&() { return _ptr; }
#endif
	IScriptHook_ptr operator->() const { return _ptr;}
	friend NCistream& operator>>(NCistream&, IScriptHook_var&);
	friend NCostream& operator<<(NCostream&, const IScriptHook_var&);
	friend istream& operator>>(istream&, IScriptHook_var&);
	friend ostream& operator<<(ostream&, const IScriptHook_var&);
    private:
	IScriptHook_ptr	_ptr;
	void operator=(const IScriptHook_var&) {}
};
#endif
class IScriptHook: public virtual CORBA_Object
{
    private:
	static const CORBA::TypeInfo _class_info;
	IScriptHook(const IScriptHook&) {}
	void operator=(const IScriptHook&){}
    public:
	static const CORBA::TypeInfo *_desc();
	virtual const CORBA::TypeInfo *_type_info() const;
	virtual void *_safe_narrow(const CORBA::TypeInfo& ) const;
	static CORBA::Object *_factory();
    protected:
	IScriptHook(const char *obj_name = NULL) :CORBA_Object(obj_name, 1) {}
	IScriptHook(NCistream& strm) :CORBA_Object(strm) {}
	virtual ~IScriptHook() {}
    public:
	static IScriptHook_ptr _duplicate(IScriptHook_ptr obj) {
		if (obj ) obj->_ref();
		return obj;
	}
	static IScriptHook_ptr _nil() { return (IScriptHook_ptr)NULL;}
	static IScriptHook_ptr _narrow(CORBA::Object *obj);
	static IScriptHook_ptr _clone(IScriptHook_ptr obj) {
		CORBA::Object_var obj_var(__clone(obj));

#if defined(_HPCC_BUG)
		return _narrow(obj_var.operator CORBA::Object_ptr());
#else
		return _narrow(obj_var);
#endif
	}
	static IScriptHook_ptr _bind(const char *object_name = NULL,
		const char *host_name = NULL,
		const CORBA::BindOptions* opt = NULL); 

	virtual void justLoadedScript(const IScript& arg0);
	
	virtual void aboutToUnloadScript(const IScript& arg0);
	
	inline friend NCistream& operator>>(NCistream& strm, IScriptHook_ptr& obj) {
		CORBA::Object_var _obj(obj);
		_obj = CORBA::Object::_read(strm, IScriptHook::_desc());
		obj = IScriptHook::_narrow(_obj);
		return strm;
	}
	inline friend ostream& operator<<(ostream& strm, const IScriptHook_ptr obj) {
		strm << (CORBA::Object_ptr)obj;
		return strm;
	}
	inline friend istream& operator>>(istream& strm, IScriptHook_ptr& obj) {
		NCistream istrm(strm);
		istrm >> obj;
		return strm;
	}
};


struct IJSStackFrameInfo {
	IJSPC	pc;
	CORBA::Long	jsdframe;
	IJSStackFrameInfo& operator=(const IJSStackFrameInfo&);
};
NCostream& operator<<(NCostream&, const IJSStackFrameInfo& );
NCistream& operator>>(NCistream&, IJSStackFrameInfo& );
inline NCistream& operator>>(NCistream& _strm, IJSStackFrameInfo*& _obj) {
	_obj = new IJSStackFrameInfo;
	_strm >> *_obj;
	return _strm;
}

ostream& operator<<(ostream&, const IJSStackFrameInfo& );
inline istream& operator>>(istream& _strm, IJSStackFrameInfo& _obj) {
	NCistream _istrm(_strm);
	_istrm >> _obj;
	return _strm;
}
inline istream& operator>>(istream& _strm, IJSStackFrameInfo*& _obj) {
	_obj = new IJSStackFrameInfo;
	_strm >> *_obj;
	return _strm;
}


typedef IJSStackFrameInfo *IJSStackFrameInfo_ptr;
class IJSStackFrameInfo_var
{
    public:
	IJSStackFrameInfo_var() { _ptr = (IJSStackFrameInfo*)NULL;}
	IJSStackFrameInfo_var(IJSStackFrameInfo *ptr) {
		_ptr = ptr;
	}
	IJSStackFrameInfo_var(const IJSStackFrameInfo_var& var) {
		if (var._ptr)
			_ptr = new IJSStackFrameInfo(*var._ptr);
		else
			_ptr = (IJSStackFrameInfo *)NULL;
	}
	~IJSStackFrameInfo_var() {
		if (_ptr != (IJSStackFrameInfo *)NULL) delete _ptr;
	}
	IJSStackFrameInfo_var& operator=(IJSStackFrameInfo *ptr) {
		if (_ptr != (IJSStackFrameInfo *)NULL) delete _ptr;
		_ptr = ptr;
		return *this;
	}
	IJSStackFrameInfo_var& operator=(const IJSStackFrameInfo_var& var) {
		if (_ptr != (IJSStackFrameInfo *)NULL) delete _ptr;
		if (var._ptr)
			_ptr = new IJSStackFrameInfo(*var._ptr);
		else
			_ptr = (IJSStackFrameInfo *)NULL;
		return *this;
	}
	IJSStackFrameInfo *operator->() { return _ptr; }
	operator IJSStackFrameInfo *() const { return _ptr; }
#if defined(_HPCC_BUG)
	operator IJSStackFrameInfo *& () { return _ptr; }
#else
	operator IJSStackFrameInfo_ptr& () { return _ptr; }
#endif
	operator IJSStackFrameInfo& () { return *_ptr; }
	inline friend NCostream& operator<<(NCostream& strm,
			const IJSStackFrameInfo_var& var) {
		if (var._ptr == (IJSStackFrameInfo *)NULL) {
			throw CORBA::BAD_PARAM();
		}
		else
			strm << *var._ptr;
		return strm;
	}
	inline friend NCistream& operator>>(NCistream& strm,
			IJSStackFrameInfo_var& var) {
		if ( ! var._ptr)
			var._ptr = new IJSStackFrameInfo;
		strm >> *var._ptr;
		return strm;
	}
    private:
	IJSStackFrameInfo *_ptr;
};


class sequence_of_IJSStackFrameInfo
{
    public:
	static IJSStackFrameInfo *allocbuf(CORBA::ULong nelems);
	static void freebuf(IJSStackFrameInfo *data);
	sequence_of_IJSStackFrameInfo(CORBA::ULong max=0);
	sequence_of_IJSStackFrameInfo(CORBA::ULong max,
		CORBA::ULong length,
		IJSStackFrameInfo *data,
		CORBA::Boolean release=0);
	sequence_of_IJSStackFrameInfo(const sequence_of_IJSStackFrameInfo&);
	~sequence_of_IJSStackFrameInfo();
	sequence_of_IJSStackFrameInfo& operator=(const sequence_of_IJSStackFrameInfo&);
	CORBA::ULong maximum() const { return _num_allocated; }
	void length(CORBA::ULong len);
	CORBA::ULong length() const { return _count;}
	IJSStackFrameInfo& operator[](CORBA::ULong index);
	const IJSStackFrameInfo& operator[](CORBA::ULong index) const;
	friend NCostream& operator<<(NCostream&, const sequence_of_IJSStackFrameInfo&);
	inline friend NCostream& operator<<(NCostream& strm, const sequence_of_IJSStackFrameInfo *obj) {
		if ( obj == (sequence_of_IJSStackFrameInfo*)NULL)
			throw CORBA::BAD_PARAM();
		else
			strm << *obj;
		return strm;
	}
	friend NCistream& operator>>(NCistream&, sequence_of_IJSStackFrameInfo&);
	inline friend NCistream& operator>>(NCistream& strm, sequence_of_IJSStackFrameInfo*& obj) {
		obj = new sequence_of_IJSStackFrameInfo;
		strm >> *obj;
		return strm;
	}
	friend ostream& operator<<(ostream&, const sequence_of_IJSStackFrameInfo&);
	inline friend istream& operator>>(istream& strm, sequence_of_IJSStackFrameInfo& obj) {
		NCistream istrm(strm);
		istrm >> obj;
		return strm;
	}
	inline friend istream& operator>>(istream& strm, sequence_of_IJSStackFrameInfo *& obj) {
		NCistream istrm(strm);
		istrm >> obj;
		return strm;
	}
	static sequence_of_IJSStackFrameInfo *_duplicate(sequence_of_IJSStackFrameInfo* ptr) {
		if (ptr) ptr->_ref_count++;
		return ptr;
	}
	static void _release(sequence_of_IJSStackFrameInfo *ptr) {
		if (ptr && ( --ptr->_ref_count == 0) )
			delete ptr;
	}
    private:
	IJSStackFrameInfo	*_contents;
	CORBA::ULong	_count;
	CORBA::ULong	_num_allocated;
	CORBA::Boolean	_release_flag;
	CORBA::Long	_ref_count;
};


typedef sequence_of_IJSStackFrameInfo *sequence_of_IJSStackFrameInfo_ptr;
class sequence_of_IJSStackFrameInfo_var
{
    public:
	sequence_of_IJSStackFrameInfo_var() : _ptr((sequence_of_IJSStackFrameInfo *)NULL) {}
	sequence_of_IJSStackFrameInfo_var(sequence_of_IJSStackFrameInfo *ptr) :_ptr(ptr) {}
	sequence_of_IJSStackFrameInfo_var(const sequence_of_IJSStackFrameInfo_var& var) :
		_ptr(sequence_of_IJSStackFrameInfo::_duplicate((sequence_of_IJSStackFrameInfo *)var)){}
	~sequence_of_IJSStackFrameInfo_var() { sequence_of_IJSStackFrameInfo::_release(_ptr); }
	sequence_of_IJSStackFrameInfo_var& operator=(sequence_of_IJSStackFrameInfo *ptr) {
		if (_ptr != ptr) {
			sequence_of_IJSStackFrameInfo::_release(_ptr);
			_ptr = ptr;
		}
		return *this;
	}
	sequence_of_IJSStackFrameInfo_var& operator=(const sequence_of_IJSStackFrameInfo_var& var) {
		sequence_of_IJSStackFrameInfo::_release(_ptr);
		_ptr = sequence_of_IJSStackFrameInfo::_duplicate((sequence_of_IJSStackFrameInfo *)var);
		return *this;
	}
	sequence_of_IJSStackFrameInfo *operator->() { return _ptr; }
	IJSStackFrameInfo& operator[](CORBA::ULong index) {
		return _ptr->operator[](index);
	}
	const IJSStackFrameInfo& operator[](CORBA::ULong index) const {
		return _ptr->operator[](index);
	}
	operator sequence_of_IJSStackFrameInfo *() const { return _ptr; }
#if defined(_HPCC_BUG)
	operator sequence_of_IJSStackFrameInfo* &() { return _ptr; }
#else
	operator sequence_of_IJSStackFrameInfo_ptr& () { return _ptr; }
#endif
	operator const sequence_of_IJSStackFrameInfo& () const { return *_ptr; }
	operator sequence_of_IJSStackFrameInfo& () { return *_ptr; }
	inline friend NCostream& operator<<(NCostream& strm, 
			const sequence_of_IJSStackFrameInfo_var& var) {
		if ( var._ptr == (sequence_of_IJSStackFrameInfo *)NULL) {
			throw CORBA::BAD_PARAM();
		}
		else
			strm << *var._ptr;
		return strm;
	}
	inline friend NCistream& operator>>(NCistream& strm,
			sequence_of_IJSStackFrameInfo_var& var) {
		if ( var._ptr == (sequence_of_IJSStackFrameInfo *)NULL )
			var._ptr = new sequence_of_IJSStackFrameInfo;
		strm >> *var._ptr;
		return strm;
	}
    private:
	sequence_of_IJSStackFrameInfo *_ptr;
};



struct IJSThreadState {
	sequence_of_IJSStackFrameInfo	stack;
	CORBA::Long	continueState;
	CORBA::String_var	returnValue;
	CORBA::Long	status;
	CORBA::Long	jsdthreadstate;
	CORBA::Long	id;
	IJSThreadState& operator=(const IJSThreadState&);
};
NCostream& operator<<(NCostream&, const IJSThreadState& );
NCistream& operator>>(NCistream&, IJSThreadState& );
inline NCistream& operator>>(NCistream& _strm, IJSThreadState*& _obj) {
	_obj = new IJSThreadState;
	_strm >> *_obj;
	return _strm;
}

ostream& operator<<(ostream&, const IJSThreadState& );
inline istream& operator>>(istream& _strm, IJSThreadState& _obj) {
	NCistream _istrm(_strm);
	_istrm >> _obj;
	return _strm;
}
inline istream& operator>>(istream& _strm, IJSThreadState*& _obj) {
	_obj = new IJSThreadState;
	_strm >> *_obj;
	return _strm;
}


typedef IJSThreadState *IJSThreadState_ptr;
class IJSThreadState_var
{
    public:
	IJSThreadState_var() { _ptr = (IJSThreadState*)NULL;}
	IJSThreadState_var(IJSThreadState *ptr) {
		_ptr = ptr;
	}
	IJSThreadState_var(const IJSThreadState_var& var) {
		if (var._ptr)
			_ptr = new IJSThreadState(*var._ptr);
		else
			_ptr = (IJSThreadState *)NULL;
	}
	~IJSThreadState_var() {
		if (_ptr != (IJSThreadState *)NULL) delete _ptr;
	}
	IJSThreadState_var& operator=(IJSThreadState *ptr) {
		if (_ptr != (IJSThreadState *)NULL) delete _ptr;
		_ptr = ptr;
		return *this;
	}
	IJSThreadState_var& operator=(const IJSThreadState_var& var) {
		if (_ptr != (IJSThreadState *)NULL) delete _ptr;
		if (var._ptr)
			_ptr = new IJSThreadState(*var._ptr);
		else
			_ptr = (IJSThreadState *)NULL;
		return *this;
	}
	IJSThreadState *operator->() { return _ptr; }
	operator IJSThreadState *() const { return _ptr; }
#if defined(_HPCC_BUG)
	operator IJSThreadState *& () { return _ptr; }
#else
	operator IJSThreadState_ptr& () { return _ptr; }
#endif
	operator IJSThreadState& () { return *_ptr; }
	inline friend NCostream& operator<<(NCostream& strm,
			const IJSThreadState_var& var) {
		if (var._ptr == (IJSThreadState *)NULL) {
			throw CORBA::BAD_PARAM();
		}
		else
			strm << *var._ptr;
		return strm;
	}
	inline friend NCistream& operator>>(NCistream& strm,
			IJSThreadState_var& var) {
		if ( ! var._ptr)
			var._ptr = new IJSThreadState;
		strm >> *var._ptr;
		return strm;
	}
    private:
	IJSThreadState *_ptr;
};


class IJSExecutionHook;
typedef IJSExecutionHook *IJSExecutionHook_ptr;
typedef IJSExecutionHook_ptr IJSExecutionHookRef;

#ifndef _IJSExecutionHook_var_
#define _IJSExecutionHook_var_
class IJSExecutionHook_var
{
    public:
	IJSExecutionHook_var();
	IJSExecutionHook_var(IJSExecutionHook_ptr);
	IJSExecutionHook_var(const IJSExecutionHook_var&);
	~IJSExecutionHook_var();
	IJSExecutionHook_var& operator=(IJSExecutionHook_ptr);
	operator IJSExecutionHook_ptr() const { return _ptr; }
#if defined(_HPCC_BUG)
	operator IJSExecutionHook *&() { return _ptr; }
#else
	operator IJSExecutionHook_ptr&() { return _ptr; }
#endif
	IJSExecutionHook_ptr operator->() const { return _ptr;}
	friend NCistream& operator>>(NCistream&, IJSExecutionHook_var&);
	friend NCostream& operator<<(NCostream&, const IJSExecutionHook_var&);
	friend istream& operator>>(istream&, IJSExecutionHook_var&);
	friend ostream& operator<<(ostream&, const IJSExecutionHook_var&);
    private:
	IJSExecutionHook_ptr	_ptr;
	void operator=(const IJSExecutionHook_var&) {}
};
#endif
class IJSExecutionHook: public virtual CORBA_Object
{
    private:
	static const CORBA::TypeInfo _class_info;
	IJSExecutionHook(const IJSExecutionHook&) {}
	void operator=(const IJSExecutionHook&){}
    public:
	static const CORBA::TypeInfo *_desc();
	virtual const CORBA::TypeInfo *_type_info() const;
	virtual void *_safe_narrow(const CORBA::TypeInfo& ) const;
	static CORBA::Object *_factory();
    protected:
	IJSExecutionHook(const char *obj_name = NULL) :CORBA_Object(obj_name, 1) {}
	IJSExecutionHook(NCistream& strm) :CORBA_Object(strm) {}
	virtual ~IJSExecutionHook() {}
    public:
	static IJSExecutionHook_ptr _duplicate(IJSExecutionHook_ptr obj) {
		if (obj ) obj->_ref();
		return obj;
	}
	static IJSExecutionHook_ptr _nil() { return (IJSExecutionHook_ptr)NULL;}
	static IJSExecutionHook_ptr _narrow(CORBA::Object *obj);
	static IJSExecutionHook_ptr _clone(IJSExecutionHook_ptr obj) {
		CORBA::Object_var obj_var(__clone(obj));

#if defined(_HPCC_BUG)
		return _narrow(obj_var.operator CORBA::Object_ptr());
#else
		return _narrow(obj_var);
#endif
	}
	static IJSExecutionHook_ptr _bind(const char *object_name = NULL,
		const char *host_name = NULL,
		const CORBA::BindOptions* opt = NULL); 

	virtual void aboutToExecute(const IJSThreadState& arg0,
			const IJSPC& arg1);
	
	inline friend NCistream& operator>>(NCistream& strm, IJSExecutionHook_ptr& obj) {
		CORBA::Object_var _obj(obj);
		_obj = CORBA::Object::_read(strm, IJSExecutionHook::_desc());
		obj = IJSExecutionHook::_narrow(_obj);
		return strm;
	}
	inline friend ostream& operator<<(ostream& strm, const IJSExecutionHook_ptr obj) {
		strm << (CORBA::Object_ptr)obj;
		return strm;
	}
	inline friend istream& operator>>(istream& strm, IJSExecutionHook_ptr& obj) {
		NCistream istrm(strm);
		istrm >> obj;
		return strm;
	}
};


struct IExecResult {
	CORBA::String_var	result;
	CORBA::Boolean	errorOccured;
	CORBA::String_var	errorMessage;
	CORBA::String_var	errorFilename;
	CORBA::Long	errorLineNumber;
	CORBA::String_var	errorLineBuffer;
	CORBA::Long	errorTokenOffset;
	IExecResult& operator=(const IExecResult&);
};
NCostream& operator<<(NCostream&, const IExecResult& );
NCistream& operator>>(NCistream&, IExecResult& );
inline NCistream& operator>>(NCistream& _strm, IExecResult*& _obj) {
	_obj = new IExecResult;
	_strm >> *_obj;
	return _strm;
}

ostream& operator<<(ostream&, const IExecResult& );
inline istream& operator>>(istream& _strm, IExecResult& _obj) {
	NCistream _istrm(_strm);
	_istrm >> _obj;
	return _strm;
}
inline istream& operator>>(istream& _strm, IExecResult*& _obj) {
	_obj = new IExecResult;
	_strm >> *_obj;
	return _strm;
}


typedef IExecResult *IExecResult_ptr;
class IExecResult_var
{
    public:
	IExecResult_var() { _ptr = (IExecResult*)NULL;}
	IExecResult_var(IExecResult *ptr) {
		_ptr = ptr;
	}
	IExecResult_var(const IExecResult_var& var) {
		if (var._ptr)
			_ptr = new IExecResult(*var._ptr);
		else
			_ptr = (IExecResult *)NULL;
	}
	~IExecResult_var() {
		if (_ptr != (IExecResult *)NULL) delete _ptr;
	}
	IExecResult_var& operator=(IExecResult *ptr) {
		if (_ptr != (IExecResult *)NULL) delete _ptr;
		_ptr = ptr;
		return *this;
	}
	IExecResult_var& operator=(const IExecResult_var& var) {
		if (_ptr != (IExecResult *)NULL) delete _ptr;
		if (var._ptr)
			_ptr = new IExecResult(*var._ptr);
		else
			_ptr = (IExecResult *)NULL;
		return *this;
	}
	IExecResult *operator->() { return _ptr; }
	operator IExecResult *() const { return _ptr; }
#if defined(_HPCC_BUG)
	operator IExecResult *& () { return _ptr; }
#else
	operator IExecResult_ptr& () { return _ptr; }
#endif
	operator IExecResult& () { return *_ptr; }
	inline friend NCostream& operator<<(NCostream& strm,
			const IExecResult_var& var) {
		if (var._ptr == (IExecResult *)NULL) {
			throw CORBA::BAD_PARAM();
		}
		else
			strm << *var._ptr;
		return strm;
	}
	inline friend NCistream& operator>>(NCistream& strm,
			IExecResult_var& var) {
		if ( ! var._ptr)
			var._ptr = new IExecResult;
		strm >> *var._ptr;
		return strm;
	}
    private:
	IExecResult *_ptr;
};


class IDebugController;
typedef IDebugController *IDebugController_ptr;
typedef IDebugController_ptr IDebugControllerRef;

#ifndef _IDebugController_var_
#define _IDebugController_var_
class IDebugController_var
{
    public:
	IDebugController_var();
	IDebugController_var(IDebugController_ptr);
	IDebugController_var(const IDebugController_var&);
	~IDebugController_var();
	IDebugController_var& operator=(IDebugController_ptr);
	operator IDebugController_ptr() const { return _ptr; }
#if defined(_HPCC_BUG)
	operator IDebugController *&() { return _ptr; }
#else
	operator IDebugController_ptr&() { return _ptr; }
#endif
	IDebugController_ptr operator->() const { return _ptr;}
	friend NCistream& operator>>(NCistream&, IDebugController_var&);
	friend NCostream& operator<<(NCostream&, const IDebugController_var&);
	friend istream& operator>>(istream&, IDebugController_var&);
	friend ostream& operator<<(ostream&, const IDebugController_var&);
    private:
	IDebugController_ptr	_ptr;
	void operator=(const IDebugController_var&) {}
};
#endif
class IDebugController: public virtual CORBA_Object
{
    private:
	static const CORBA::TypeInfo _class_info;
	IDebugController(const IDebugController&) {}
	void operator=(const IDebugController&){}
    public:
	static const CORBA::TypeInfo *_desc();
	virtual const CORBA::TypeInfo *_type_info() const;
	virtual void *_safe_narrow(const CORBA::TypeInfo& ) const;
	static CORBA::Object *_factory();
    protected:
	IDebugController(const char *obj_name = NULL) :CORBA_Object(obj_name, 1) {}
	IDebugController(NCistream& strm) :CORBA_Object(strm) {}
	virtual ~IDebugController() {}
    public:
	static IDebugController_ptr _duplicate(IDebugController_ptr obj) {
		if (obj ) obj->_ref();
		return obj;
	}
	static IDebugController_ptr _nil() { return (IDebugController_ptr)NULL;}
	static IDebugController_ptr _narrow(CORBA::Object *obj);
	static IDebugController_ptr _clone(IDebugController_ptr obj) {
		CORBA::Object_var obj_var(__clone(obj));

#if defined(_HPCC_BUG)
		return _narrow(obj_var.operator CORBA::Object_ptr());
#else
		return _narrow(obj_var);
#endif
	}
	static IDebugController_ptr _bind(const char *object_name = NULL,
		const char *host_name = NULL,
		const CORBA::BindOptions* opt = NULL); 

	virtual CORBA::Long getMajorVersion();
	
	virtual CORBA::Long getMinorVersion();
	
	virtual IJSErrorReporter_ptr setErrorReporter(IJSErrorReporter_ptr arg0);
	
	virtual IJSErrorReporter_ptr getErrorReporter();
	
	virtual IScriptHook_ptr setScriptHook(IScriptHook_ptr arg0);
	
	virtual IScriptHook_ptr getScriptHook();
	
	virtual IJSPC * getClosestPC(const IScript& arg0,
			CORBA::Long arg1);
	
	virtual IJSSourceLocation * getSourceLocation(const IJSPC& arg0);
	
	virtual IJSExecutionHook_ptr setInterruptHook(IJSExecutionHook_ptr arg0);
	
	virtual IJSExecutionHook_ptr getInterruptHook();
	
	virtual IJSExecutionHook_ptr setDebugBreakHook(IJSExecutionHook_ptr arg0);
	
	virtual IJSExecutionHook_ptr getDebugBreakHook();
	
	virtual IJSExecutionHook_ptr setInstructionHook(IJSExecutionHook_ptr arg0,
			const IJSPC& arg1);
	
	virtual IJSExecutionHook_ptr getInstructionHook(const IJSPC& arg0);
	
	virtual void setThreadContinueState(CORBA::Long arg0,
			CORBA::Long arg1);
	
	virtual void setThreadReturnValue(CORBA::Long arg0,
			const char * arg1);
	
	virtual void sendInterrupt();
	
	virtual void sendInterruptStepInto(CORBA::Long arg0);
	
	virtual void sendInterruptStepOver(CORBA::Long arg0);
	
	virtual void sendInterruptStepOut(CORBA::Long arg0);
	
	virtual void reinstateStepper(CORBA::Long arg0);
	
	virtual IExecResult * executeScriptInStackFrame(CORBA::Long arg0,
			const IJSStackFrameInfo& arg1,
			const char * arg2,
			const char * arg3,
			CORBA::Long arg4);
	
	virtual CORBA::Boolean isRunningHook(CORBA::Long arg0);
	
	virtual CORBA::Boolean isWaitingForResume(CORBA::Long arg0);
	
	virtual void leaveThreadSuspended(CORBA::Long arg0);
	
	virtual void resumeThread(CORBA::Long arg0);
	
	virtual void iterateScripts(IScriptHook_ptr arg0);
	
	inline friend NCistream& operator>>(NCistream& strm, IDebugController_ptr& obj) {
		CORBA::Object_var _obj(obj);
		_obj = CORBA::Object::_read(strm, IDebugController::_desc());
		obj = IDebugController::_narrow(_obj);
		return strm;
	}
	inline friend ostream& operator<<(ostream& strm, const IDebugController_ptr obj) {
		strm << (CORBA::Object_ptr)obj;
		return strm;
	}
	inline friend istream& operator>>(istream& strm, IDebugController_ptr& obj) {
		NCistream istrm(strm);
		istrm >> obj;
		return strm;
	}
};


#endif

