/************************************************************************/
/*                                                                      */
/* This file is automatically generated by ORBeline IDL compiler        */
/* Do not modify this file.                                             */
/*                                                                      */
/* ORBeline (c) is copyrighted by PostModern Computing, Inc.            */
/*                                                                      */
/* The generated code conforms to OMG's IDL C++ mapping as              */
/* specified in OMG Document Number: 94-9-14.                           */
/*                                                                      */
/************************************************************************/

#include "ifaces_c.hh"


Thing& Thing::operator=(const Thing& _s)
{
	s = _s.s;
	i = _s.i;
	return *this;
}
NCostream& operator<<(NCostream& strm, const Thing& _s)
{
	strm << _s.s;
	strm << _s.i;
	return strm;
}

NCistream& operator>>(NCistream& strm, Thing& _s)
{
	strm >> _s.s;
	strm >> _s.i;
	return strm;
}

ostream& operator<<(ostream& strm, const Thing& _s)
{
	if (&strm == &cout || &strm == &cerr || &strm == &clog) {
		strm << "struct Thing {" << endl;
		strm << "\ts: " << _s.s << endl;
		strm << "\ti: " << _s.i << endl;
		strm << "}" << endl;
	}
	else {
		NCostream ostrm(strm);
		ostrm << _s;
	}
	return strm;
}

const CORBA::TypeInfo StringReciever::_class_info("StringReciever",
		"IDL:StringReciever:1.0",
		&StringReciever::_factory,
		CORBA::Object::_desc(),
		0);
const CORBA::TypeInfo *StringReciever::_desc()
{
	return &_class_info;
}
const CORBA::TypeInfo *StringReciever::_type_info() const
{
	return &_class_info;
}
void *StringReciever::_safe_narrow(const CORBA::TypeInfo& _info) const
{
	if (_class_info == _info)
		return (void *) this;
	return CORBA_Object::_safe_narrow(_info);
}
StringReciever *StringReciever::_narrow(CORBA::Object *obj)
{
	if (obj == CORBA::Object::_nil())
		return StringReciever::_nil();
	else
		return StringReciever::_duplicate((StringReciever_ptr)obj->_safe_narrow(_class_info));
}
CORBA::Object *StringReciever::_factory()
{
	return new StringReciever;
}
StringReciever *StringReciever::_bind(const char *_object_name,
		const char *_host_name, const CORBA::BindOptions *_opt)
{
	StringReciever *_impl;
	CORBA::Object *_obj = _implementation(
				"StringReciever", 
				_object_name,
				_host_name);
	if (!_obj) {
		_impl = new StringReciever(_object_name);
		try {
			_impl->CORBA_Object::_bind(
				"StringReciever",
				_object_name,
				_host_name,
				_opt);
		}
		catch(const CORBA::Exception& ) {
			delete _impl;
			_impl = (StringReciever *)NULL;
			throw;
		}
	}
	else
		_impl = StringReciever::_narrow(_obj);
	return _impl;
}
void StringReciever::recieveString(
		const char * arg0)
{
	CORBA::MarshalStream *_strm = _create_request(
			"recieveString",
			1,
			335599);
	*_strm << arg0;

	try {
		_invoke();
	}
	catch (const CORBA::TRANSIENT& ) {
			recieveString(
				arg0);
			return;
	}
	_strm->flushRead();
}

void StringReciever::bounce(
		CORBA::Long arg0)
{
	CORBA::MarshalStream *_strm = _create_request(
			"bounce",
			1,
			2051);
	*_strm << arg0;

	try {
		_invoke();
	}
	catch (const CORBA::TRANSIENT& ) {
			bounce(
				arg0);
			return;
	}
	_strm->flushRead();
}

StringReciever_var::StringReciever_var()
		: _ptr(StringReciever::_nil()) {}
StringReciever_var::StringReciever_var(StringReciever_ptr ptr)
		: _ptr(ptr) {}
StringReciever_var::StringReciever_var(const StringReciever_var& var)
		:_ptr(StringReciever::_duplicate((StringReciever_ptr)var)) {}
StringReciever_var::~StringReciever_var()
{
	CORBA::release(_ptr);
}
StringReciever_var& StringReciever_var::operator=(StringReciever_ptr p)
{
	if (_ptr != p) {
		CORBA::release(_ptr);
		_ptr = p;
	}
	return *this;
}
NCistream& operator>>(NCistream& strm, StringReciever_var& var)
{
	strm >> var._ptr;
	return strm;
}
NCostream& operator<<(NCostream& strm, const StringReciever_var& var)
{
	strm << var._ptr;
	return strm;
}
istream& operator>>(istream& strm, StringReciever_var& var)
{
	NCistream istrm(strm);
	istrm >> var._ptr;
	return strm;
}
ostream& operator<<(ostream& strm, const StringReciever_var& var)
{
	strm << (CORBA::Object_ptr)var._ptr;
	return strm;
}
const CORBA::TypeInfo TestInterface::_class_info("TestInterface",
		"IDL:TestInterface:1.0",
		&TestInterface::_factory,
		CORBA::Object::_desc(),
		0);
const CORBA::TypeInfo *TestInterface::_desc()
{
	return &_class_info;
}
const CORBA::TypeInfo *TestInterface::_type_info() const
{
	return &_class_info;
}
void *TestInterface::_safe_narrow(const CORBA::TypeInfo& _info) const
{
	if (_class_info == _info)
		return (void *) this;
	return CORBA_Object::_safe_narrow(_info);
}
TestInterface *TestInterface::_narrow(CORBA::Object *obj)
{
	if (obj == CORBA::Object::_nil())
		return TestInterface::_nil();
	else
		return TestInterface::_duplicate((TestInterface_ptr)obj->_safe_narrow(_class_info));
}
CORBA::Object *TestInterface::_factory()
{
	return new TestInterface;
}
TestInterface *TestInterface::_bind(const char *_object_name,
		const char *_host_name, const CORBA::BindOptions *_opt)
{
	TestInterface *_impl;
	CORBA::Object *_obj = _implementation(
				"TestInterface", 
				_object_name,
				_host_name);
	if (!_obj) {
		_impl = new TestInterface(_object_name);
		try {
			_impl->CORBA_Object::_bind(
				"TestInterface",
				_object_name,
				_host_name,
				_opt);
		}
		catch(const CORBA::Exception& ) {
			delete _impl;
			_impl = (TestInterface *)NULL;
			throw;
		}
	}
	else
		_impl = TestInterface::_narrow(_obj);
	return _impl;
}
char * TestInterface::getFirstAppInList()
{
	char *_ret = (char *)NULL;
	CORBA::MarshalStream *_strm = _create_request(
			"getFirstAppInList",
			1,
			4459926);

	try {
		_invoke();
	}
	catch (const CORBA::TRANSIENT& ) {
			return getFirstAppInList();
	}
	*_strm >> _ret;
	_strm->flushRead();
	return _ret;
}

void TestInterface::getAppNames(
		StringReciever_ptr arg0)
{
	CORBA::MarshalStream *_strm = _create_request(
			"getAppNames",
			1,
			71269);
	*_strm << arg0;

	try {
		_invoke();
	}
	catch (const CORBA::TRANSIENT& ) {
			getAppNames(
				arg0);
			return;
	}
	_strm->flushRead();
}


Thing* TestInterface::sequence_of_Thing::allocbuf(CORBA::ULong nelems)
{
	return new Thing[nelems];
}
void TestInterface::sequence_of_Thing::freebuf(Thing *data)
{
	if (data) delete[] data;
}
Thing& TestInterface::sequence_of_Thing::operator[](CORBA::ULong index)
{
	if (index >= _count)
		throw CORBA::BAD_PARAM();
	return _contents[index];
}
const Thing& TestInterface::sequence_of_Thing::operator[](CORBA::ULong index) const
{
	if (index >= _count)
		throw CORBA::BAD_PARAM();
	return _contents[index];
}

NCistream& operator>>(NCistream& strm,  TestInterface::sequence_of_Thing& seq)
{
	CORBA::ULong t_count;
	strm >> t_count;
	if (t_count > seq._count) {
		if (seq._num_allocated < t_count) {
			if (seq._release_flag)
				TestInterface::sequence_of_Thing::freebuf(seq._contents);
			else
				seq._release_flag = 1;
			seq._contents = TestInterface::sequence_of_Thing::allocbuf(t_count);
			seq._num_allocated = t_count;
		}
	}
	seq._count = t_count;
	for (CORBA::ULong i=0; i< seq._count; i++)
		strm >> seq._contents[i];
	return strm;
}

NCostream&  operator<<(NCostream& strm, const TestInterface::sequence_of_Thing& seq)
{
	strm << seq._count;
	for (CORBA::ULong i=0; i< seq._count; i++)
		strm << seq._contents[i];
	return strm;
}
ostream& operator<<(ostream& strm, const TestInterface::sequence_of_Thing& seq)
{
	if (&strm == &cout || &strm == &cerr || &strm == &clog) {
		strm << "SEQUENCE NAME: TestInterface::sequence_of_Thing" << endl;
		strm << "NUM OF ELEMENTS: " << seq._count << endl;
		for (CORBA::ULong i=0; i< seq._count; i++) {
			strm << "ELEMENT NUM: " << i << " = ";
			strm << seq._contents[i] << endl;
		}
	}
	else {
		NCostream ostrm(strm);
		ostrm << seq;
	}
	return strm;
}

TestInterface::sequence_of_Thing::sequence_of_Thing(CORBA::ULong max)
{
	_num_allocated = max;
	_count = 0;
	if (_num_allocated > 0)
		_contents = allocbuf(_num_allocated);
	else
		_contents = (Thing *)NULL;
	_release_flag = 1;
	_ref_count = 1;
}

TestInterface::sequence_of_Thing::sequence_of_Thing(CORBA::ULong max,
		CORBA::ULong len,
		Thing *data,
		CORBA::Boolean release_flag)
{
	_num_allocated = max;
	_count = len;
	_contents = data;
	_release_flag = release_flag;
	_ref_count = 1;
}

TestInterface::sequence_of_Thing::sequence_of_Thing(const TestInterface::sequence_of_Thing& seq)
{
	_num_allocated = seq._num_allocated;
	_count = seq._count;
	if (_num_allocated > 0)
		_contents = allocbuf(_num_allocated);
	else
		_contents = (Thing *)NULL;
	for (CORBA::ULong i=0; i< _count; i++)
		_contents[i] = seq._contents[i];
	_release_flag = 1;
	_ref_count = 1;
}

TestInterface::sequence_of_Thing::~sequence_of_Thing()
{
	if (_release_flag)
		freebuf(_contents);
}

TestInterface::sequence_of_Thing& TestInterface::sequence_of_Thing::operator=(const TestInterface::sequence_of_Thing& seq)
{
	if (_count < seq._count) {
		if (_num_allocated < seq._count) {
			if (_release_flag)
				freebuf(_contents);
			else
				_release_flag = 1;
			_contents = allocbuf(seq._num_allocated);
			_num_allocated = seq._num_allocated;
		}
	}
	_count = seq._count;
	for (CORBA::ULong i=0; i< _count; i++)
		_contents[i] = seq._contents[i];
	return *this;
}

void TestInterface::sequence_of_Thing::length(CORBA::ULong newlen)
{
	if (newlen > _num_allocated) {
		Thing *temp = allocbuf(newlen);
		for (CORBA::ULong i=0; i< _count; i++)
			temp[i] = _contents[i];
		if (_release_flag)
			freebuf(_contents);
		else
			_release_flag = 1;
		_num_allocated = newlen;
		_contents = temp;
	}
	_count = newlen;
}




TestInterface::sequence_of_Thing * TestInterface::getThings()
{
	TestInterface::sequence_of_Thing *_ret = (TestInterface::sequence_of_Thing *)0;
	CORBA::MarshalStream *_strm = _create_request(
			"getThings",
			1,
			18125);

	try {
		_invoke();
	}
	catch (const CORBA::TRANSIENT& ) {
			return getThings();
	}
	*_strm >> _ret;
	_strm->flushRead();
	return _ret;
}

void TestInterface::callBounce(
		StringReciever_ptr arg0,
		CORBA::Long arg1)
{
	CORBA::MarshalStream *_strm = _create_request(
			"callBounce",
			1,
			34307);
	*_strm << arg0;
	*_strm << arg1;

	try {
		_invoke();
	}
	catch (const CORBA::TRANSIENT& ) {
			callBounce(
				arg0,
				arg1);
			return;
	}
	_strm->flushRead();
}

TestInterface_var::TestInterface_var()
		: _ptr(TestInterface::_nil()) {}
TestInterface_var::TestInterface_var(TestInterface_ptr ptr)
		: _ptr(ptr) {}
TestInterface_var::TestInterface_var(const TestInterface_var& var)
		:_ptr(TestInterface::_duplicate((TestInterface_ptr)var)) {}
TestInterface_var::~TestInterface_var()
{
	CORBA::release(_ptr);
}
TestInterface_var& TestInterface_var::operator=(TestInterface_ptr p)
{
	if (_ptr != p) {
		CORBA::release(_ptr);
		_ptr = p;
	}
	return *this;
}
NCistream& operator>>(NCistream& strm, TestInterface_var& var)
{
	strm >> var._ptr;
	return strm;
}
NCostream& operator<<(NCostream& strm, const TestInterface_var& var)
{
	strm << var._ptr;
	return strm;
}
istream& operator>>(istream& strm, TestInterface_var& var)
{
	NCistream istrm(strm);
	istrm >> var._ptr;
	return strm;
}
ostream& operator<<(ostream& strm, const TestInterface_var& var)
{
	strm << (CORBA::Object_ptr)var._ptr;
	return strm;
}
const CORBA::TypeInfo ISourceTextProvider::_class_info("ISourceTextProvider",
		"IDL:ISourceTextProvider:1.0",
		&ISourceTextProvider::_factory,
		CORBA::Object::_desc(),
		0);
const CORBA::TypeInfo *ISourceTextProvider::_desc()
{
	return &_class_info;
}
const CORBA::TypeInfo *ISourceTextProvider::_type_info() const
{
	return &_class_info;
}
void *ISourceTextProvider::_safe_narrow(const CORBA::TypeInfo& _info) const
{
	if (_class_info == _info)
		return (void *) this;
	return CORBA_Object::_safe_narrow(_info);
}
ISourceTextProvider *ISourceTextProvider::_narrow(CORBA::Object *obj)
{
	if (obj == CORBA::Object::_nil())
		return ISourceTextProvider::_nil();
	else
		return ISourceTextProvider::_duplicate((ISourceTextProvider_ptr)obj->_safe_narrow(_class_info));
}
CORBA::Object *ISourceTextProvider::_factory()
{
	return new ISourceTextProvider;
}
ISourceTextProvider *ISourceTextProvider::_bind(const char *_object_name,
		const char *_host_name, const CORBA::BindOptions *_opt)
{
	ISourceTextProvider *_impl;
	CORBA::Object *_obj = _implementation(
				"ISourceTextProvider", 
				_object_name,
				_host_name);
	if (!_obj) {
		_impl = new ISourceTextProvider(_object_name);
		try {
			_impl->CORBA_Object::_bind(
				"ISourceTextProvider",
				_object_name,
				_host_name,
				_opt);
		}
		catch(const CORBA::Exception& ) {
			delete _impl;
			_impl = (ISourceTextProvider *)NULL;
			throw;
		}
	}
	else
		_impl = ISourceTextProvider::_narrow(_obj);
	return _impl;
}

NCistream& operator>>(NCistream& strm,  ISourceTextProvider::sequence_of_string& seq)
{
	CORBA::ULong t_count;
	strm >> t_count;
	if (t_count > seq._count) {
		if (seq._num_allocated < t_count) { 
			if (seq.release_on_copy())
				ISourceTextProvider::sequence_of_string::freebuf_elems(seq._buffer, seq._num_allocated);
			seq._buffer = ISourceTextProvider::sequence_of_string::allocbuf(t_count);
			seq._num_allocated = t_count;
			seq.release_on_copy(1);
		}
	}
	seq._count = t_count;
	for (CORBA::ULong i=0; i< t_count; i++)
		strm >> seq._buffer[i];
	return strm;
}

NCostream&  operator<<(NCostream& strm, const ISourceTextProvider::sequence_of_string& seq)
{
	strm << seq._count;
	for (CORBA::ULong i=0; i< seq._count; i++)
		strm << seq._buffer[i];
	return strm;
}
ostream& operator<<(ostream& strm, const ISourceTextProvider::sequence_of_string& seq)
{
	if (&strm == &cout || &strm == &cerr || &strm == &clog) {
		strm << "SEQUENCE NAME: ISourceTextProvider::sequence_of_string" << endl;
		strm << "NUM OF ELEMENTS: " << seq._count << endl;
		for (CORBA::ULong i=0; i< seq._count; i++) {
			strm << "ELEMENT NUM: " << i << " = ";
			strm << seq._buffer[i] << endl;
		}
	}
	else {
		NCostream ostrm(strm);
		ostrm << seq;
	}
	return strm;
}

ISourceTextProvider::sequence_of_string::sequence_of_string(CORBA::ULong max)
{
	_num_allocated = max;
	_count = 0;
	if (max > 0)
		_buffer = allocbuf(max);
	else
		_buffer = (char **)NULL;
	release_on_copy(1); 
	_ref_count =1;
}

ISourceTextProvider::sequence_of_string::sequence_of_string(CORBA::ULong max,
		CORBA::ULong len,
		char **data,
		CORBA::Boolean release_flag)
{
	_num_allocated = max;
	_count = len;
	release_on_copy(release_flag);
	_buffer = data;
	_ref_count = 1;
}

ISourceTextProvider::sequence_of_string::sequence_of_string(const ISourceTextProvider::sequence_of_string& seq)
{
	_num_allocated = seq._num_allocated;
	_count = seq._count;
	release_on_copy(1);
	_ref_count = 1;
	if (_num_allocated > 0) {
		_buffer = allocbuf(_num_allocated);
		for (CORBA::ULong i=0; i< _count; i++) {
			if (seq._buffer[i]) {
				_buffer[i] = CORBA::string_alloc(
					strlen(seq._buffer[i]));
				strcpy(_buffer[i], seq._buffer[i]);
			}
		}
	}
	else
		_buffer = (char **)NULL;
}

ISourceTextProvider::sequence_of_string::~sequence_of_string()
{
	if (release_on_copy())
		freebuf_elems(_buffer, _num_allocated);
}

ISourceTextProvider::sequence_of_string& ISourceTextProvider::sequence_of_string::operator=(const ISourceTextProvider::sequence_of_string& seq)
{
	if (release_on_copy() )
		freebuf_elems(_buffer, _num_allocated);
	release_on_copy(1);
	_num_allocated = seq._num_allocated;
	_count = seq._count;
	if (_num_allocated > 0) {
		_buffer = allocbuf(_num_allocated);
		for (CORBA::ULong i=0; i< _count; i++) {
			if (seq._buffer[i]) {
				_buffer[i] = CORBA::string_alloc(
					strlen(seq._buffer[i]));
				strcpy(_buffer[i], seq._buffer[i]);
			}
		}
	}
	else
		_buffer = (char **)NULL;
	return *this;
}

void ISourceTextProvider::sequence_of_string::length(CORBA::ULong newlen)
{
	if (newlen > _num_allocated) {
		char  **temp = allocbuf(newlen);
		if (release_on_copy()) {
			for (CORBA::ULong i=0; i< _count; i++)
				temp[i] = _buffer[i];
			freebuf(_buffer);
		}
		_buffer = temp;
		_num_allocated = newlen;
	}
	_count = newlen;
}



ISourceTextProvider::sequence_of_string * ISourceTextProvider::getAllPages()
{
	ISourceTextProvider::sequence_of_string *_ret = (ISourceTextProvider::sequence_of_string *)0;
	CORBA::MarshalStream *_strm = _create_request(
			"getAllPages",
			1,
			70445);

	try {
		_invoke();
	}
	catch (const CORBA::TRANSIENT& ) {
			return getAllPages();
	}
	*_strm >> _ret;
	_strm->flushRead();
	return _ret;
}

void ISourceTextProvider::refreshAllPages()
{
	CORBA::MarshalStream *_strm = _create_request(
			"refreshAllPages",
			1,
			1375021);

	try {
		_invoke();
	}
	catch (const CORBA::TRANSIENT& ) {
			refreshAllPages();
			return;
	}
	_strm->flushRead();
}

CORBA::Boolean ISourceTextProvider::hasPage(
		const char * arg0)
{
	CORBA::Boolean _ret = (CORBA::Boolean)0;
	CORBA::MarshalStream *_strm = _create_request(
			"hasPage",
			1,
			4799);
	*_strm << arg0;

	try {
		_invoke();
	}
	catch (const CORBA::TRANSIENT& ) {
			return hasPage(
				arg0);
	}
	*_strm >> _ret;
	_strm->flushRead();
	return _ret;
}

CORBA::Boolean ISourceTextProvider::loadPage(
		const char * arg0)
{
	CORBA::Boolean _ret = (CORBA::Boolean)0;
	CORBA::MarshalStream *_strm = _create_request(
			"loadPage",
			1,
			9231);
	*_strm << arg0;

	try {
		_invoke();
	}
	catch (const CORBA::TRANSIENT& ) {
			return loadPage(
				arg0);
	}
	*_strm >> _ret;
	_strm->flushRead();
	return _ret;
}

void ISourceTextProvider::refreshPage(
		const char * arg0)
{
	CORBA::MarshalStream *_strm = _create_request(
			"refreshPage",
			1,
			85775);
	*_strm << arg0;

	try {
		_invoke();
	}
	catch (const CORBA::TRANSIENT& ) {
			refreshPage(
				arg0);
			return;
	}
	_strm->flushRead();
}

char * ISourceTextProvider::getPageText(
		const char * arg0)
{
	char *_ret = (char *)NULL;
	CORBA::MarshalStream *_strm = _create_request(
			"getPageText",
			1,
			72512);
	*_strm << arg0;

	try {
		_invoke();
	}
	catch (const CORBA::TRANSIENT& ) {
			return getPageText(
				arg0);
	}
	*_strm >> _ret;
	_strm->flushRead();
	return _ret;
}

CORBA::Long ISourceTextProvider::getPageStatus(
		const char * arg0)
{
	CORBA::Long _ret = (CORBA::Long)0;
	CORBA::MarshalStream *_strm = _create_request(
			"getPageStatus",
			1,
			289953);
	*_strm << arg0;

	try {
		_invoke();
	}
	catch (const CORBA::TRANSIENT& ) {
			return getPageStatus(
				arg0);
	}
	*_strm >> _ret;
	_strm->flushRead();
	return _ret;
}

CORBA::Long ISourceTextProvider::getPageAlterCount(
		const char * arg0)
{
	CORBA::Long _ret = (CORBA::Long)0;
	CORBA::MarshalStream *_strm = _create_request(
			"getPageAlterCount",
			1,
			4651316);
	*_strm << arg0;

	try {
		_invoke();
	}
	catch (const CORBA::TRANSIENT& ) {
			return getPageAlterCount(
				arg0);
	}
	*_strm >> _ret;
	_strm->flushRead();
	return _ret;
}

ISourceTextProvider_var::ISourceTextProvider_var()
		: _ptr(ISourceTextProvider::_nil()) {}
ISourceTextProvider_var::ISourceTextProvider_var(ISourceTextProvider_ptr ptr)
		: _ptr(ptr) {}
ISourceTextProvider_var::ISourceTextProvider_var(const ISourceTextProvider_var& var)
		:_ptr(ISourceTextProvider::_duplicate((ISourceTextProvider_ptr)var)) {}
ISourceTextProvider_var::~ISourceTextProvider_var()
{
	CORBA::release(_ptr);
}
ISourceTextProvider_var& ISourceTextProvider_var::operator=(ISourceTextProvider_ptr p)
{
	if (_ptr != p) {
		CORBA::release(_ptr);
		_ptr = p;
	}
	return *this;
}
NCistream& operator>>(NCistream& strm, ISourceTextProvider_var& var)
{
	strm >> var._ptr;
	return strm;
}
NCostream& operator<<(NCostream& strm, const ISourceTextProvider_var& var)
{
	strm << var._ptr;
	return strm;
}
istream& operator>>(istream& strm, ISourceTextProvider_var& var)
{
	NCistream istrm(strm);
	istrm >> var._ptr;
	return strm;
}
ostream& operator<<(ostream& strm, const ISourceTextProvider_var& var)
{
	strm << (CORBA::Object_ptr)var._ptr;
	return strm;
}

NCostream& operator<<(NCostream& strm, const IScriptSection& _s)
{
	strm << _s.base;
	strm << _s.extent;
	return strm;
}

NCistream& operator>>(NCistream& strm, IScriptSection& _s)
{
	strm >> _s.base;
	strm >> _s.extent;
	return strm;
}

ostream& operator<<(ostream& strm, const IScriptSection& _s)
{
	if (&strm == &cout || &strm == &cerr || &strm == &clog) {
		strm << "struct IScriptSection {" << endl;
		strm << "\tbase: " << _s.base << endl;
		strm << "\textent: " << _s.extent << endl;
		strm << "}" << endl;
	}
	else {
		NCostream ostrm(strm);
		ostrm << _s;
	}
	return strm;
}


IScriptSection* sequence_of_IScriptSection::allocbuf(CORBA::ULong nelems)
{
	return new IScriptSection[nelems];
}
void sequence_of_IScriptSection::freebuf(IScriptSection *data)
{
	if (data) delete[] data;
}
IScriptSection& sequence_of_IScriptSection::operator[](CORBA::ULong index)
{
	if (index >= _count)
		throw CORBA::BAD_PARAM();
	return _contents[index];
}
const IScriptSection& sequence_of_IScriptSection::operator[](CORBA::ULong index) const
{
	if (index >= _count)
		throw CORBA::BAD_PARAM();
	return _contents[index];
}

NCistream& operator>>(NCistream& strm,  sequence_of_IScriptSection& seq)
{
	CORBA::ULong t_count;
	strm >> t_count;
	if (t_count > seq._count) {
		if (seq._num_allocated < t_count) {
			if (seq._release_flag)
				sequence_of_IScriptSection::freebuf(seq._contents);
			else
				seq._release_flag = 1;
			seq._contents = sequence_of_IScriptSection::allocbuf(t_count);
			seq._num_allocated = t_count;
		}
	}
	seq._count = t_count;
	for (CORBA::ULong i=0; i< seq._count; i++)
		strm >> seq._contents[i];
	return strm;
}

NCostream&  operator<<(NCostream& strm, const sequence_of_IScriptSection& seq)
{
	strm << seq._count;
	for (CORBA::ULong i=0; i< seq._count; i++)
		strm << seq._contents[i];
	return strm;
}
ostream& operator<<(ostream& strm, const sequence_of_IScriptSection& seq)
{
	if (&strm == &cout || &strm == &cerr || &strm == &clog) {
		strm << "SEQUENCE NAME: sequence_of_IScriptSection" << endl;
		strm << "NUM OF ELEMENTS: " << seq._count << endl;
		for (CORBA::ULong i=0; i< seq._count; i++) {
			strm << "ELEMENT NUM: " << i << " = ";
			strm << seq._contents[i] << endl;
		}
	}
	else {
		NCostream ostrm(strm);
		ostrm << seq;
	}
	return strm;
}

sequence_of_IScriptSection::sequence_of_IScriptSection(CORBA::ULong max)
{
	_num_allocated = max;
	_count = 0;
	if (_num_allocated > 0)
		_contents = allocbuf(_num_allocated);
	else
		_contents = (IScriptSection *)NULL;
	_release_flag = 1;
	_ref_count = 1;
}

sequence_of_IScriptSection::sequence_of_IScriptSection(CORBA::ULong max,
		CORBA::ULong len,
		IScriptSection *data,
		CORBA::Boolean release_flag)
{
	_num_allocated = max;
	_count = len;
	_contents = data;
	_release_flag = release_flag;
	_ref_count = 1;
}

sequence_of_IScriptSection::sequence_of_IScriptSection(const sequence_of_IScriptSection& seq)
{
	_num_allocated = seq._num_allocated;
	_count = seq._count;
	if (_num_allocated > 0)
		_contents = allocbuf(_num_allocated);
	else
		_contents = (IScriptSection *)NULL;
	for (CORBA::ULong i=0; i< _count; i++)
		_contents[i] = seq._contents[i];
	_release_flag = 1;
	_ref_count = 1;
}

sequence_of_IScriptSection::~sequence_of_IScriptSection()
{
	if (_release_flag)
		freebuf(_contents);
}

sequence_of_IScriptSection& sequence_of_IScriptSection::operator=(const sequence_of_IScriptSection& seq)
{
	if (_count < seq._count) {
		if (_num_allocated < seq._count) {
			if (_release_flag)
				freebuf(_contents);
			else
				_release_flag = 1;
			_contents = allocbuf(seq._num_allocated);
			_num_allocated = seq._num_allocated;
		}
	}
	_count = seq._count;
	for (CORBA::ULong i=0; i< _count; i++)
		_contents[i] = seq._contents[i];
	return *this;
}

void sequence_of_IScriptSection::length(CORBA::ULong newlen)
{
	if (newlen > _num_allocated) {
		IScriptSection *temp = allocbuf(newlen);
		for (CORBA::ULong i=0; i< _count; i++)
			temp[i] = _contents[i];
		if (_release_flag)
			freebuf(_contents);
		else
			_release_flag = 1;
		_num_allocated = newlen;
		_contents = temp;
	}
	_count = newlen;
}




IScript& IScript::operator=(const IScript& _s)
{
	url = _s.url;
	funname = _s.funname;
	base = _s.base;
	extent = _s.extent;
	jsdscript = _s.jsdscript;
	sections = _s.sections;
	return *this;
}
NCostream& operator<<(NCostream& strm, const IScript& _s)
{
	strm << _s.url;
	strm << _s.funname;
	strm << _s.base;
	strm << _s.extent;
	strm << _s.jsdscript;
	strm << _s.sections;
	return strm;
}

NCistream& operator>>(NCistream& strm, IScript& _s)
{
	strm >> _s.url;
	strm >> _s.funname;
	strm >> _s.base;
	strm >> _s.extent;
	strm >> _s.jsdscript;
	strm >> _s.sections;
	return strm;
}

ostream& operator<<(ostream& strm, const IScript& _s)
{
	if (&strm == &cout || &strm == &cerr || &strm == &clog) {
		strm << "struct IScript {" << endl;
		strm << "\turl: " << _s.url << endl;
		strm << "\tfunname: " << _s.funname << endl;
		strm << "\tbase: " << _s.base << endl;
		strm << "\textent: " << _s.extent << endl;
		strm << "\tjsdscript: " << _s.jsdscript << endl;
		strm << "\tsections: " << _s.sections << endl;
		strm << "}" << endl;
	}
	else {
		NCostream ostrm(strm);
		ostrm << _s;
	}
	return strm;
}


IJSPC& IJSPC::operator=(const IJSPC& _s)
{
	script = _s.script;
	offset = _s.offset;
	return *this;
}
NCostream& operator<<(NCostream& strm, const IJSPC& _s)
{
	strm << _s.script;
	strm << _s.offset;
	return strm;
}

NCistream& operator>>(NCistream& strm, IJSPC& _s)
{
	strm >> _s.script;
	strm >> _s.offset;
	return strm;
}

ostream& operator<<(ostream& strm, const IJSPC& _s)
{
	if (&strm == &cout || &strm == &cerr || &strm == &clog) {
		strm << "struct IJSPC {" << endl;
		strm << "\tscript: " << _s.script << endl;
		strm << "\toffset: " << _s.offset << endl;
		strm << "}" << endl;
	}
	else {
		NCostream ostrm(strm);
		ostrm << _s;
	}
	return strm;
}


IJSSourceLocation& IJSSourceLocation::operator=(const IJSSourceLocation& _s)
{
	line = _s.line;
	pc = _s.pc;
	return *this;
}
NCostream& operator<<(NCostream& strm, const IJSSourceLocation& _s)
{
	strm << _s.line;
	strm << _s.pc;
	return strm;
}

NCistream& operator>>(NCistream& strm, IJSSourceLocation& _s)
{
	strm >> _s.line;
	strm >> _s.pc;
	return strm;
}

ostream& operator<<(ostream& strm, const IJSSourceLocation& _s)
{
	if (&strm == &cout || &strm == &cerr || &strm == &clog) {
		strm << "struct IJSSourceLocation {" << endl;
		strm << "\tline: " << _s.line << endl;
		strm << "\tpc: " << _s.pc << endl;
		strm << "}" << endl;
	}
	else {
		NCostream ostrm(strm);
		ostrm << _s;
	}
	return strm;
}

const CORBA::TypeInfo IJSErrorReporter::_class_info("IJSErrorReporter",
		"IDL:IJSErrorReporter:1.0",
		&IJSErrorReporter::_factory,
		CORBA::Object::_desc(),
		0);
const CORBA::TypeInfo *IJSErrorReporter::_desc()
{
	return &_class_info;
}
const CORBA::TypeInfo *IJSErrorReporter::_type_info() const
{
	return &_class_info;
}
void *IJSErrorReporter::_safe_narrow(const CORBA::TypeInfo& _info) const
{
	if (_class_info == _info)
		return (void *) this;
	return CORBA_Object::_safe_narrow(_info);
}
IJSErrorReporter *IJSErrorReporter::_narrow(CORBA::Object *obj)
{
	if (obj == CORBA::Object::_nil())
		return IJSErrorReporter::_nil();
	else
		return IJSErrorReporter::_duplicate((IJSErrorReporter_ptr)obj->_safe_narrow(_class_info));
}
CORBA::Object *IJSErrorReporter::_factory()
{
	return new IJSErrorReporter;
}
IJSErrorReporter *IJSErrorReporter::_bind(const char *_object_name,
		const char *_host_name, const CORBA::BindOptions *_opt)
{
	IJSErrorReporter *_impl;
	CORBA::Object *_obj = _implementation(
				"IJSErrorReporter", 
				_object_name,
				_host_name);
	if (!_obj) {
		_impl = new IJSErrorReporter(_object_name);
		try {
			_impl->CORBA_Object::_bind(
				"IJSErrorReporter",
				_object_name,
				_host_name,
				_opt);
		}
		catch(const CORBA::Exception& ) {
			delete _impl;
			_impl = (IJSErrorReporter *)NULL;
			throw;
		}
	}
	else
		_impl = IJSErrorReporter::_narrow(_obj);
	return _impl;
}
CORBA::Long IJSErrorReporter::reportError(
		const char * arg0,
		const char * arg1,
		CORBA::Long arg2,
		const char * arg3,
		CORBA::Long arg4)
{
	CORBA::Long _ret = (CORBA::Long)0;
	CORBA::MarshalStream *_strm = _create_request(
			"reportError",
			1,
			86308);
	*_strm << arg0;
	*_strm << arg1;
	*_strm << arg2;
	*_strm << arg3;
	*_strm << arg4;

	try {
		_invoke();
	}
	catch (const CORBA::TRANSIENT& ) {
			return reportError(
				arg0,
				arg1,
				arg2,
				arg3,
				arg4);
	}
	*_strm >> _ret;
	_strm->flushRead();
	return _ret;
}

IJSErrorReporter_var::IJSErrorReporter_var()
		: _ptr(IJSErrorReporter::_nil()) {}
IJSErrorReporter_var::IJSErrorReporter_var(IJSErrorReporter_ptr ptr)
		: _ptr(ptr) {}
IJSErrorReporter_var::IJSErrorReporter_var(const IJSErrorReporter_var& var)
		:_ptr(IJSErrorReporter::_duplicate((IJSErrorReporter_ptr)var)) {}
IJSErrorReporter_var::~IJSErrorReporter_var()
{
	CORBA::release(_ptr);
}
IJSErrorReporter_var& IJSErrorReporter_var::operator=(IJSErrorReporter_ptr p)
{
	if (_ptr != p) {
		CORBA::release(_ptr);
		_ptr = p;
	}
	return *this;
}
NCistream& operator>>(NCistream& strm, IJSErrorReporter_var& var)
{
	strm >> var._ptr;
	return strm;
}
NCostream& operator<<(NCostream& strm, const IJSErrorReporter_var& var)
{
	strm << var._ptr;
	return strm;
}
istream& operator>>(istream& strm, IJSErrorReporter_var& var)
{
	NCistream istrm(strm);
	istrm >> var._ptr;
	return strm;
}
ostream& operator<<(ostream& strm, const IJSErrorReporter_var& var)
{
	strm << (CORBA::Object_ptr)var._ptr;
	return strm;
}
const CORBA::TypeInfo IScriptHook::_class_info("IScriptHook",
		"IDL:IScriptHook:1.0",
		&IScriptHook::_factory,
		CORBA::Object::_desc(),
		0);
const CORBA::TypeInfo *IScriptHook::_desc()
{
	return &_class_info;
}
const CORBA::TypeInfo *IScriptHook::_type_info() const
{
	return &_class_info;
}
void *IScriptHook::_safe_narrow(const CORBA::TypeInfo& _info) const
{
	if (_class_info == _info)
		return (void *) this;
	return CORBA_Object::_safe_narrow(_info);
}
IScriptHook *IScriptHook::_narrow(CORBA::Object *obj)
{
	if (obj == CORBA::Object::_nil())
		return IScriptHook::_nil();
	else
		return IScriptHook::_duplicate((IScriptHook_ptr)obj->_safe_narrow(_class_info));
}
CORBA::Object *IScriptHook::_factory()
{
	return new IScriptHook;
}
IScriptHook *IScriptHook::_bind(const char *_object_name,
		const char *_host_name, const CORBA::BindOptions *_opt)
{
	IScriptHook *_impl;
	CORBA::Object *_obj = _implementation(
				"IScriptHook", 
				_object_name,
				_host_name);
	if (!_obj) {
		_impl = new IScriptHook(_object_name);
		try {
			_impl->CORBA_Object::_bind(
				"IScriptHook",
				_object_name,
				_host_name,
				_opt);
		}
		catch(const CORBA::Exception& ) {
			delete _impl;
			_impl = (IScriptHook *)NULL;
			throw;
		}
	}
	else
		_impl = IScriptHook::_narrow(_obj);
	return _impl;
}
void IScriptHook::justLoadedScript(
		const IScript& arg0)
{
	CORBA::MarshalStream *_strm = _create_request(
			"justLoadedScript",
			1,
			2244464);
	*_strm << arg0;

	try {
		_invoke();
	}
	catch (const CORBA::TRANSIENT& ) {
			justLoadedScript(
				arg0);
			return;
	}
	_strm->flushRead();
}

void IScriptHook::aboutToUnloadScript(
		const IScript& arg0)
{
	CORBA::MarshalStream *_strm = _create_request(
			"aboutToUnloadScript",
			1,
			17264752);
	*_strm << arg0;

	try {
		_invoke();
	}
	catch (const CORBA::TRANSIENT& ) {
			aboutToUnloadScript(
				arg0);
			return;
	}
	_strm->flushRead();
}

IScriptHook_var::IScriptHook_var()
		: _ptr(IScriptHook::_nil()) {}
IScriptHook_var::IScriptHook_var(IScriptHook_ptr ptr)
		: _ptr(ptr) {}
IScriptHook_var::IScriptHook_var(const IScriptHook_var& var)
		:_ptr(IScriptHook::_duplicate((IScriptHook_ptr)var)) {}
IScriptHook_var::~IScriptHook_var()
{
	CORBA::release(_ptr);
}
IScriptHook_var& IScriptHook_var::operator=(IScriptHook_ptr p)
{
	if (_ptr != p) {
		CORBA::release(_ptr);
		_ptr = p;
	}
	return *this;
}
NCistream& operator>>(NCistream& strm, IScriptHook_var& var)
{
	strm >> var._ptr;
	return strm;
}
NCostream& operator<<(NCostream& strm, const IScriptHook_var& var)
{
	strm << var._ptr;
	return strm;
}
istream& operator>>(istream& strm, IScriptHook_var& var)
{
	NCistream istrm(strm);
	istrm >> var._ptr;
	return strm;
}
ostream& operator<<(ostream& strm, const IScriptHook_var& var)
{
	strm << (CORBA::Object_ptr)var._ptr;
	return strm;
}

IJSStackFrameInfo& IJSStackFrameInfo::operator=(const IJSStackFrameInfo& _s)
{
	pc = _s.pc;
	jsdframe = _s.jsdframe;
	return *this;
}
NCostream& operator<<(NCostream& strm, const IJSStackFrameInfo& _s)
{
	strm << _s.pc;
	strm << _s.jsdframe;
	return strm;
}

NCistream& operator>>(NCistream& strm, IJSStackFrameInfo& _s)
{
	strm >> _s.pc;
	strm >> _s.jsdframe;
	return strm;
}

ostream& operator<<(ostream& strm, const IJSStackFrameInfo& _s)
{
	if (&strm == &cout || &strm == &cerr || &strm == &clog) {
		strm << "struct IJSStackFrameInfo {" << endl;
		strm << "\tpc: " << _s.pc << endl;
		strm << "\tjsdframe: " << _s.jsdframe << endl;
		strm << "}" << endl;
	}
	else {
		NCostream ostrm(strm);
		ostrm << _s;
	}
	return strm;
}


IJSStackFrameInfo* sequence_of_IJSStackFrameInfo::allocbuf(CORBA::ULong nelems)
{
	return new IJSStackFrameInfo[nelems];
}
void sequence_of_IJSStackFrameInfo::freebuf(IJSStackFrameInfo *data)
{
	if (data) delete[] data;
}
IJSStackFrameInfo& sequence_of_IJSStackFrameInfo::operator[](CORBA::ULong index)
{
	if (index >= _count)
		throw CORBA::BAD_PARAM();
	return _contents[index];
}
const IJSStackFrameInfo& sequence_of_IJSStackFrameInfo::operator[](CORBA::ULong index) const
{
	if (index >= _count)
		throw CORBA::BAD_PARAM();
	return _contents[index];
}

NCistream& operator>>(NCistream& strm,  sequence_of_IJSStackFrameInfo& seq)
{
	CORBA::ULong t_count;
	strm >> t_count;
	if (t_count > seq._count) {
		if (seq._num_allocated < t_count) {
			if (seq._release_flag)
				sequence_of_IJSStackFrameInfo::freebuf(seq._contents);
			else
				seq._release_flag = 1;
			seq._contents = sequence_of_IJSStackFrameInfo::allocbuf(t_count);
			seq._num_allocated = t_count;
		}
	}
	seq._count = t_count;
	for (CORBA::ULong i=0; i< seq._count; i++)
		strm >> seq._contents[i];
	return strm;
}

NCostream&  operator<<(NCostream& strm, const sequence_of_IJSStackFrameInfo& seq)
{
	strm << seq._count;
	for (CORBA::ULong i=0; i< seq._count; i++)
		strm << seq._contents[i];
	return strm;
}
ostream& operator<<(ostream& strm, const sequence_of_IJSStackFrameInfo& seq)
{
	if (&strm == &cout || &strm == &cerr || &strm == &clog) {
		strm << "SEQUENCE NAME: sequence_of_IJSStackFrameInfo" << endl;
		strm << "NUM OF ELEMENTS: " << seq._count << endl;
		for (CORBA::ULong i=0; i< seq._count; i++) {
			strm << "ELEMENT NUM: " << i << " = ";
			strm << seq._contents[i] << endl;
		}
	}
	else {
		NCostream ostrm(strm);
		ostrm << seq;
	}
	return strm;
}

sequence_of_IJSStackFrameInfo::sequence_of_IJSStackFrameInfo(CORBA::ULong max)
{
	_num_allocated = max;
	_count = 0;
	if (_num_allocated > 0)
		_contents = allocbuf(_num_allocated);
	else
		_contents = (IJSStackFrameInfo *)NULL;
	_release_flag = 1;
	_ref_count = 1;
}

sequence_of_IJSStackFrameInfo::sequence_of_IJSStackFrameInfo(CORBA::ULong max,
		CORBA::ULong len,
		IJSStackFrameInfo *data,
		CORBA::Boolean release_flag)
{
	_num_allocated = max;
	_count = len;
	_contents = data;
	_release_flag = release_flag;
	_ref_count = 1;
}

sequence_of_IJSStackFrameInfo::sequence_of_IJSStackFrameInfo(const sequence_of_IJSStackFrameInfo& seq)
{
	_num_allocated = seq._num_allocated;
	_count = seq._count;
	if (_num_allocated > 0)
		_contents = allocbuf(_num_allocated);
	else
		_contents = (IJSStackFrameInfo *)NULL;
	for (CORBA::ULong i=0; i< _count; i++)
		_contents[i] = seq._contents[i];
	_release_flag = 1;
	_ref_count = 1;
}

sequence_of_IJSStackFrameInfo::~sequence_of_IJSStackFrameInfo()
{
	if (_release_flag)
		freebuf(_contents);
}

sequence_of_IJSStackFrameInfo& sequence_of_IJSStackFrameInfo::operator=(const sequence_of_IJSStackFrameInfo& seq)
{
	if (_count < seq._count) {
		if (_num_allocated < seq._count) {
			if (_release_flag)
				freebuf(_contents);
			else
				_release_flag = 1;
			_contents = allocbuf(seq._num_allocated);
			_num_allocated = seq._num_allocated;
		}
	}
	_count = seq._count;
	for (CORBA::ULong i=0; i< _count; i++)
		_contents[i] = seq._contents[i];
	return *this;
}

void sequence_of_IJSStackFrameInfo::length(CORBA::ULong newlen)
{
	if (newlen > _num_allocated) {
		IJSStackFrameInfo *temp = allocbuf(newlen);
		for (CORBA::ULong i=0; i< _count; i++)
			temp[i] = _contents[i];
		if (_release_flag)
			freebuf(_contents);
		else
			_release_flag = 1;
		_num_allocated = newlen;
		_contents = temp;
	}
	_count = newlen;
}




IJSThreadState& IJSThreadState::operator=(const IJSThreadState& _s)
{
	stack = _s.stack;
	continueState = _s.continueState;
	returnValue = _s.returnValue;
	status = _s.status;
	jsdthreadstate = _s.jsdthreadstate;
	id = _s.id;
	return *this;
}
NCostream& operator<<(NCostream& strm, const IJSThreadState& _s)
{
	strm << _s.stack;
	strm << _s.continueState;
	strm << _s.returnValue;
	strm << _s.status;
	strm << _s.jsdthreadstate;
	strm << _s.id;
	return strm;
}

NCistream& operator>>(NCistream& strm, IJSThreadState& _s)
{
	strm >> _s.stack;
	strm >> _s.continueState;
	strm >> _s.returnValue;
	strm >> _s.status;
	strm >> _s.jsdthreadstate;
	strm >> _s.id;
	return strm;
}

ostream& operator<<(ostream& strm, const IJSThreadState& _s)
{
	if (&strm == &cout || &strm == &cerr || &strm == &clog) {
		strm << "struct IJSThreadState {" << endl;
		strm << "\tstack: " << _s.stack << endl;
		strm << "\tcontinueState: " << _s.continueState << endl;
		strm << "\treturnValue: " << _s.returnValue << endl;
		strm << "\tstatus: " << _s.status << endl;
		strm << "\tjsdthreadstate: " << _s.jsdthreadstate << endl;
		strm << "\tid: " << _s.id << endl;
		strm << "}" << endl;
	}
	else {
		NCostream ostrm(strm);
		ostrm << _s;
	}
	return strm;
}

const CORBA::TypeInfo IJSExecutionHook::_class_info("IJSExecutionHook",
		"IDL:IJSExecutionHook:1.0",
		&IJSExecutionHook::_factory,
		CORBA::Object::_desc(),
		0);
const CORBA::TypeInfo *IJSExecutionHook::_desc()
{
	return &_class_info;
}
const CORBA::TypeInfo *IJSExecutionHook::_type_info() const
{
	return &_class_info;
}
void *IJSExecutionHook::_safe_narrow(const CORBA::TypeInfo& _info) const
{
	if (_class_info == _info)
		return (void *) this;
	return CORBA_Object::_safe_narrow(_info);
}
IJSExecutionHook *IJSExecutionHook::_narrow(CORBA::Object *obj)
{
	if (obj == CORBA::Object::_nil())
		return IJSExecutionHook::_nil();
	else
		return IJSExecutionHook::_duplicate((IJSExecutionHook_ptr)obj->_safe_narrow(_class_info));
}
CORBA::Object *IJSExecutionHook::_factory()
{
	return new IJSExecutionHook;
}
IJSExecutionHook *IJSExecutionHook::_bind(const char *_object_name,
		const char *_host_name, const CORBA::BindOptions *_opt)
{
	IJSExecutionHook *_impl;
	CORBA::Object *_obj = _implementation(
				"IJSExecutionHook", 
				_object_name,
				_host_name);
	if (!_obj) {
		_impl = new IJSExecutionHook(_object_name);
		try {
			_impl->CORBA_Object::_bind(
				"IJSExecutionHook",
				_object_name,
				_host_name,
				_opt);
		}
		catch(const CORBA::Exception& ) {
			delete _impl;
			_impl = (IJSExecutionHook *)NULL;
			throw;
		}
	}
	else
		_impl = IJSExecutionHook::_narrow(_obj);
	return _impl;
}
void IJSExecutionHook::aboutToExecute(
		const IJSThreadState& arg0,
		const IJSPC& arg1)
{
	CORBA::MarshalStream *_strm = _create_request(
			"aboutToExecute",
			1,
			540113);
	*_strm << arg0;
	*_strm << arg1;

	try {
		_invoke();
	}
	catch (const CORBA::TRANSIENT& ) {
			aboutToExecute(
				arg0,
				arg1);
			return;
	}
	_strm->flushRead();
}

IJSExecutionHook_var::IJSExecutionHook_var()
		: _ptr(IJSExecutionHook::_nil()) {}
IJSExecutionHook_var::IJSExecutionHook_var(IJSExecutionHook_ptr ptr)
		: _ptr(ptr) {}
IJSExecutionHook_var::IJSExecutionHook_var(const IJSExecutionHook_var& var)
		:_ptr(IJSExecutionHook::_duplicate((IJSExecutionHook_ptr)var)) {}
IJSExecutionHook_var::~IJSExecutionHook_var()
{
	CORBA::release(_ptr);
}
IJSExecutionHook_var& IJSExecutionHook_var::operator=(IJSExecutionHook_ptr p)
{
	if (_ptr != p) {
		CORBA::release(_ptr);
		_ptr = p;
	}
	return *this;
}
NCistream& operator>>(NCistream& strm, IJSExecutionHook_var& var)
{
	strm >> var._ptr;
	return strm;
}
NCostream& operator<<(NCostream& strm, const IJSExecutionHook_var& var)
{
	strm << var._ptr;
	return strm;
}
istream& operator>>(istream& strm, IJSExecutionHook_var& var)
{
	NCistream istrm(strm);
	istrm >> var._ptr;
	return strm;
}
ostream& operator<<(ostream& strm, const IJSExecutionHook_var& var)
{
	strm << (CORBA::Object_ptr)var._ptr;
	return strm;
}

IExecResult& IExecResult::operator=(const IExecResult& _s)
{
	result = _s.result;
	errorOccured = _s.errorOccured;
	errorMessage = _s.errorMessage;
	errorFilename = _s.errorFilename;
	errorLineNumber = _s.errorLineNumber;
	errorLineBuffer = _s.errorLineBuffer;
	errorTokenOffset = _s.errorTokenOffset;
	return *this;
}
NCostream& operator<<(NCostream& strm, const IExecResult& _s)
{
	strm << _s.result;
	strm << _s.errorOccured;
	strm << _s.errorMessage;
	strm << _s.errorFilename;
	strm << _s.errorLineNumber;
	strm << _s.errorLineBuffer;
	strm << _s.errorTokenOffset;
	return strm;
}

NCistream& operator>>(NCistream& strm, IExecResult& _s)
{
	strm >> _s.result;
	strm >> _s.errorOccured;
	strm >> _s.errorMessage;
	strm >> _s.errorFilename;
	strm >> _s.errorLineNumber;
	strm >> _s.errorLineBuffer;
	strm >> _s.errorTokenOffset;
	return strm;
}

ostream& operator<<(ostream& strm, const IExecResult& _s)
{
	if (&strm == &cout || &strm == &cerr || &strm == &clog) {
		strm << "struct IExecResult {" << endl;
		strm << "\tresult: " << _s.result << endl;
		strm << "\terrorOccured: " << (int)_s.errorOccured << endl;
		strm << "\terrorMessage: " << _s.errorMessage << endl;
		strm << "\terrorFilename: " << _s.errorFilename << endl;
		strm << "\terrorLineNumber: " << _s.errorLineNumber << endl;
		strm << "\terrorLineBuffer: " << _s.errorLineBuffer << endl;
		strm << "\terrorTokenOffset: " << _s.errorTokenOffset << endl;
		strm << "}" << endl;
	}
	else {
		NCostream ostrm(strm);
		ostrm << _s;
	}
	return strm;
}

const CORBA::TypeInfo IDebugController::_class_info("IDebugController",
		"IDL:IDebugController:1.0",
		&IDebugController::_factory,
		CORBA::Object::_desc(),
		0);
const CORBA::TypeInfo *IDebugController::_desc()
{
	return &_class_info;
}
const CORBA::TypeInfo *IDebugController::_type_info() const
{
	return &_class_info;
}
void *IDebugController::_safe_narrow(const CORBA::TypeInfo& _info) const
{
	if (_class_info == _info)
		return (void *) this;
	return CORBA_Object::_safe_narrow(_info);
}
IDebugController *IDebugController::_narrow(CORBA::Object *obj)
{
	if (obj == CORBA::Object::_nil())
		return IDebugController::_nil();
	else
		return IDebugController::_duplicate((IDebugController_ptr)obj->_safe_narrow(_class_info));
}
CORBA::Object *IDebugController::_factory()
{
	return new IDebugController;
}
IDebugController *IDebugController::_bind(const char *_object_name,
		const char *_host_name, const CORBA::BindOptions *_opt)
{
	IDebugController *_impl;
	CORBA::Object *_obj = _implementation(
				"IDebugController", 
				_object_name,
				_host_name);
	if (!_obj) {
		_impl = new IDebugController(_object_name);
		try {
			_impl->CORBA_Object::_bind(
				"IDebugController",
				_object_name,
				_host_name,
				_opt);
		}
		catch(const CORBA::Exception& ) {
			delete _impl;
			_impl = (IDebugController *)NULL;
			throw;
		}
	}
	else
		_impl = IDebugController::_narrow(_obj);
	return _impl;
}
CORBA::Long IDebugController::getMajorVersion()
{
	CORBA::Long _ret = (CORBA::Long)0;
	CORBA::MarshalStream *_strm = _create_request(
			"getMajorVersion",
			1,
			1135244);

	try {
		_invoke();
	}
	catch (const CORBA::TRANSIENT& ) {
			return getMajorVersion();
	}
	*_strm >> _ret;
	_strm->flushRead();
	return _ret;
}

CORBA::Long IDebugController::getMinorVersion()
{
	CORBA::Long _ret = (CORBA::Long)0;
	CORBA::MarshalStream *_strm = _create_request(
			"getMinorVersion",
			1,
			1145484);

	try {
		_invoke();
	}
	catch (const CORBA::TRANSIENT& ) {
			return getMinorVersion();
	}
	*_strm >> _ret;
	_strm->flushRead();
	return _ret;
}

IJSErrorReporter_ptr IDebugController::setErrorReporter(
		IJSErrorReporter_ptr arg0)
{
	IJSErrorReporter_ptr _ret = IJSErrorReporter::_nil();
	CORBA::MarshalStream *_strm = _create_request(
			"setErrorReporter",
			1,
			2678344);
	*_strm << arg0;

	try {
		_invoke();
	}
	catch (const CORBA::TRANSIENT& ) {
			return setErrorReporter(
				arg0);
	}
	*_strm >> _ret;
	_strm->flushRead();
	return _ret;
}

IJSErrorReporter_ptr IDebugController::getErrorReporter()
{
	IJSErrorReporter_ptr _ret = IJSErrorReporter::_nil();
	CORBA::MarshalStream *_strm = _create_request(
			"getErrorReporter",
			1,
			2285128);

	try {
		_invoke();
	}
	catch (const CORBA::TRANSIENT& ) {
			return getErrorReporter();
	}
	*_strm >> _ret;
	_strm->flushRead();
	return _ret;
}

IScriptHook_ptr IDebugController::setScriptHook(
		IScriptHook_ptr arg0)
{
	IScriptHook_ptr _ret = IScriptHook::_nil();
	CORBA::MarshalStream *_strm = _create_request(
			"setScriptHook",
			1,
			336969);
	*_strm << arg0;

	try {
		_invoke();
	}
	catch (const CORBA::TRANSIENT& ) {
			return setScriptHook(
				arg0);
	}
	*_strm >> _ret;
	_strm->flushRead();
	return _ret;
}

IScriptHook_ptr IDebugController::getScriptHook()
{
	IScriptHook_ptr _ret = IScriptHook::_nil();
	CORBA::MarshalStream *_strm = _create_request(
			"getScriptHook",
			1,
			287817);

	try {
		_invoke();
	}
	catch (const CORBA::TRANSIENT& ) {
			return getScriptHook();
	}
	*_strm >> _ret;
	_strm->flushRead();
	return _ret;
}

IJSPC * IDebugController::getClosestPC(
		const IScript& arg0,
		CORBA::Long arg1)
{
	IJSPC *_ret = (IJSPC *)0;
	CORBA::MarshalStream *_strm = _create_request(
			"getClosestPC",
			1,
			139355);
	*_strm << arg0;
	*_strm << arg1;

	try {
		_invoke();
	}
	catch (const CORBA::TRANSIENT& ) {
			return getClosestPC(
				arg0,
				arg1);
	}
	*_strm >> _ret;
	_strm->flushRead();
	return _ret;
}

IJSSourceLocation * IDebugController::getSourceLocation(
		const IJSPC& arg0)
{
	IJSSourceLocation *_ret = (IJSSourceLocation *)0;
	CORBA::MarshalStream *_strm = _create_request(
			"getSourceLocation",
			1,
			4646404);
	*_strm << arg0;

	try {
		_invoke();
	}
	catch (const CORBA::TRANSIENT& ) {
			return getSourceLocation(
				arg0);
	}
	*_strm >> _ret;
	_strm->flushRead();
	return _ret;
}

IJSExecutionHook_ptr IDebugController::setInterruptHook(
		IJSExecutionHook_ptr arg0)
{
	IJSExecutionHook_ptr _ret = IJSExecutionHook::_nil();
	CORBA::MarshalStream *_strm = _create_request(
			"setInterruptHook",
			1,
			2680393);
	*_strm << arg0;

	try {
		_invoke();
	}
	catch (const CORBA::TRANSIENT& ) {
			return setInterruptHook(
				arg0);
	}
	*_strm >> _ret;
	_strm->flushRead();
	return _ret;
}

IJSExecutionHook_ptr IDebugController::getInterruptHook()
{
	IJSExecutionHook_ptr _ret = IJSExecutionHook::_nil();
	CORBA::MarshalStream *_strm = _create_request(
			"getInterruptHook",
			1,
			2287177);

	try {
		_invoke();
	}
	catch (const CORBA::TRANSIENT& ) {
			return getInterruptHook();
	}
	*_strm >> _ret;
	_strm->flushRead();
	return _ret;
}

IJSExecutionHook_ptr IDebugController::setDebugBreakHook(
		IJSExecutionHook_ptr arg0)
{
	IJSExecutionHook_ptr _ret = IJSExecutionHook::_nil();
	CORBA::MarshalStream *_strm = _create_request(
			"setDebugBreakHook",
			1,
			5255577);
	*_strm << arg0;

	try {
		_invoke();
	}
	catch (const CORBA::TRANSIENT& ) {
			return setDebugBreakHook(
				arg0);
	}
	*_strm >> _ret;
	_strm->flushRead();
	return _ret;
}

IJSExecutionHook_ptr IDebugController::getDebugBreakHook()
{
	IJSExecutionHook_ptr _ret = IJSExecutionHook::_nil();
	CORBA::MarshalStream *_strm = _create_request(
			"getDebugBreakHook",
			1,
			4469145);

	try {
		_invoke();
	}
	catch (const CORBA::TRANSIENT& ) {
			return getDebugBreakHook();
	}
	*_strm >> _ret;
	_strm->flushRead();
	return _ret;
}

IJSExecutionHook_ptr IDebugController::setInstructionHook(
		IJSExecutionHook_ptr arg0,
		const IJSPC& arg1)
{
	IJSExecutionHook_ptr _ret = IJSExecutionHook::_nil();
	CORBA::MarshalStream *_strm = _create_request(
			"setInstructionHook",
			1,
			10713353);
	*_strm << arg0;
	*_strm << arg1;

	try {
		_invoke();
	}
	catch (const CORBA::TRANSIENT& ) {
			return setInstructionHook(
				arg0,
				arg1);
	}
	*_strm >> _ret;
	_strm->flushRead();
	return _ret;
}

IJSExecutionHook_ptr IDebugController::getInstructionHook(
		const IJSPC& arg0)
{
	IJSExecutionHook_ptr _ret = IJSExecutionHook::_nil();
	CORBA::MarshalStream *_strm = _create_request(
			"getInstructionHook",
			1,
			9140489);
	*_strm << arg0;

	try {
		_invoke();
	}
	catch (const CORBA::TRANSIENT& ) {
			return getInstructionHook(
				arg0);
	}
	*_strm >> _ret;
	_strm->flushRead();
	return _ret;
}

void IDebugController::setThreadContinueState(
		CORBA::Long arg0,
		CORBA::Long arg1)
{
	CORBA::MarshalStream *_strm = _create_request(
			"setThreadContinueState",
			1,
			172101753);
	*_strm << arg0;
	*_strm << arg1;

	try {
		_invoke();
	}
	catch (const CORBA::TRANSIENT& ) {
			setThreadContinueState(
				arg0,
				arg1);
			return;
	}
	_strm->flushRead();
}

void IDebugController::setThreadReturnValue(
		CORBA::Long arg0,
		const char * arg1)
{
	CORBA::MarshalStream *_strm = _create_request(
			"setThreadReturnValue",
			1,
			43043479);
	*_strm << arg0;
	*_strm << arg1;

	try {
		_invoke();
	}
	catch (const CORBA::TRANSIENT& ) {
			setThreadReturnValue(
				arg0,
				arg1);
			return;
	}
	_strm->flushRead();
}

void IDebugController::sendInterrupt()
{
	CORBA::MarshalStream *_strm = _create_request(
			"sendInterrupt",
			1,
			328272);

	try {
		_invoke();
	}
	catch (const CORBA::TRANSIENT& ) {
			sendInterrupt();
			return;
	}
	_strm->flushRead();
}

void IDebugController::sendInterruptStepInto(
		CORBA::Long arg0)
{
	CORBA::MarshalStream *_strm = _create_request(
			"sendInterruptStepInto",
			1,
			84044887);
	*_strm << arg0;

	try {
		_invoke();
	}
	catch (const CORBA::TRANSIENT& ) {
			sendInterruptStepInto(
				arg0);
			return;
	}
	_strm->flushRead();
}

void IDebugController::sendInterruptStepOver(
		CORBA::Long arg0)
{
	CORBA::MarshalStream *_strm = _create_request(
			"sendInterruptStepOver",
			1,
			84044856);
	*_strm << arg0;

	try {
		_invoke();
	}
	catch (const CORBA::TRANSIENT& ) {
			sendInterruptStepOver(
				arg0);
			return;
	}
	_strm->flushRead();
}

void IDebugController::sendInterruptStepOut(
		CORBA::Long arg0)
{
	CORBA::MarshalStream *_strm = _create_request(
			"sendInterruptStepOut",
			1,
			42022450);
	*_strm << arg0;

	try {
		_invoke();
	}
	catch (const CORBA::TRANSIENT& ) {
			sendInterruptStepOut(
				arg0);
			return;
	}
	_strm->flushRead();
}

void IDebugController::reinstateStepper(
		CORBA::Long arg0)
{
	CORBA::MarshalStream *_strm = _create_request(
			"reinstateStepper",
			1,
			2708072);
	*_strm << arg0;

	try {
		_invoke();
	}
	catch (const CORBA::TRANSIENT& ) {
			reinstateStepper(
				arg0);
			return;
	}
	_strm->flushRead();
}

IExecResult * IDebugController::executeScriptInStackFrame(
		CORBA::Long arg0,
		const IJSStackFrameInfo& arg1,
		const char * arg2,
		const char * arg3,
		CORBA::Long arg4)
{
	IExecResult *_ret = (IExecResult *)0;
	CORBA::MarshalStream *_strm = _create_request(
			"executeScriptInStackFrame",
			1,
			1235747307);
	*_strm << arg0;
	*_strm << arg1;
	*_strm << arg2;
	*_strm << arg3;
	*_strm << arg4;

	try {
		_invoke();
	}
	catch (const CORBA::TRANSIENT& ) {
			return executeScriptInStackFrame(
				arg0,
				arg1,
				arg2,
				arg3,
				arg4);
	}
	*_strm >> _ret;
	_strm->flushRead();
	return _ret;
}

CORBA::Boolean IDebugController::isRunningHook(
		CORBA::Long arg0)
{
	CORBA::Boolean _ret = (CORBA::Boolean)0;
	CORBA::MarshalStream *_strm = _create_request(
			"isRunningHook",
			1,
			319929);
	*_strm << arg0;

	try {
		_invoke();
	}
	catch (const CORBA::TRANSIENT& ) {
			return isRunningHook(
				arg0);
	}
	*_strm >> _ret;
	_strm->flushRead();
	return _ret;
}

CORBA::Boolean IDebugController::isWaitingForResume(
		CORBA::Long arg0)
{
	CORBA::Boolean _ret = (CORBA::Boolean)0;
	CORBA::MarshalStream *_strm = _create_request(
			"isWaitingForResume",
			1,
			10157539);
	*_strm << arg0;

	try {
		_invoke();
	}
	catch (const CORBA::TRANSIENT& ) {
			return isWaitingForResume(
				arg0);
	}
	*_strm >> _ret;
	_strm->flushRead();
	return _ret;
}

void IDebugController::leaveThreadSuspended(
		CORBA::Long arg0)
{
	CORBA::MarshalStream *_strm = _create_request(
			"leaveThreadSuspended",
			1,
			40876894);
	*_strm << arg0;

	try {
		_invoke();
	}
	catch (const CORBA::TRANSIENT& ) {
			leaveThreadSuspended(
				arg0);
			return;
	}
	_strm->flushRead();
}

void IDebugController::resumeThread(
		CORBA::Long arg0)
{
	CORBA::MarshalStream *_strm = _create_request(
			"resumeThread",
			1,
			177762);
	*_strm << arg0;

	try {
		_invoke();
	}
	catch (const CORBA::TRANSIENT& ) {
			resumeThread(
				arg0);
			return;
	}
	_strm->flushRead();
}

void IDebugController::iterateScripts(
		IScriptHook_ptr arg0)
{
	CORBA::MarshalStream *_strm = _create_request(
			"iterateScripts",
			1,
			530707);
	*_strm << arg0;

	try {
		_invoke();
	}
	catch (const CORBA::TRANSIENT& ) {
			iterateScripts(
				arg0);
			return;
	}
	_strm->flushRead();
}

IDebugController_var::IDebugController_var()
		: _ptr(IDebugController::_nil()) {}
IDebugController_var::IDebugController_var(IDebugController_ptr ptr)
		: _ptr(ptr) {}
IDebugController_var::IDebugController_var(const IDebugController_var& var)
		:_ptr(IDebugController::_duplicate((IDebugController_ptr)var)) {}
IDebugController_var::~IDebugController_var()
{
	CORBA::release(_ptr);
}
IDebugController_var& IDebugController_var::operator=(IDebugController_ptr p)
{
	if (_ptr != p) {
		CORBA::release(_ptr);
		_ptr = p;
	}
	return *this;
}
NCistream& operator>>(NCistream& strm, IDebugController_var& var)
{
	strm >> var._ptr;
	return strm;
}
NCostream& operator<<(NCostream& strm, const IDebugController_var& var)
{
	strm << var._ptr;
	return strm;
}
istream& operator>>(istream& strm, IDebugController_var& var)
{
	NCistream istrm(strm);
	istrm >> var._ptr;
	return strm;
}
ostream& operator<<(ostream& strm, const IDebugController_var& var)
{
	strm << (CORBA::Object_ptr)var._ptr;
	return strm;
}

