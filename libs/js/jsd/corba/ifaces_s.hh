#ifndef _ifaces_s_hh
#define _ifaces_s_hh

#include "ifaces_c.hh"

/************************************************************************/
/*                                                                      */
/* This file is automatically generated by ORBeline IDL compiler        */
/* Do not modify this file.                                             */
/*                                                                      */
/* ORBeline (c) is copyrighted by PostModern Computing, Inc.            */
/*                                                                      */
/* The generated code conforms to OMG's IDL C++ mapping as              */
/* specified in OMG Document Number: 94-9-14.                           */
/*                                                                      */
/************************************************************************/

class _sk_StringReciever : public StringReciever
{
    protected:
	_sk_StringReciever(const char *object_name = (const char *)NULL);
	_sk_StringReciever(const char *service_name, const CORBA::ReferenceData& data);
	virtual ~_sk_StringReciever() {}
    public:
	static const CORBA::TypeInfo _skel_info;

	// The following operations need to be implemented by the server.
	virtual void recieveString(const char * arg0) = 0;
	virtual void bounce(CORBA::Long arg0) = 0;
	
	// Skeleton Operations implemented automatically
	
	static void _recieveString(void *obj,
			CORBA::MarshalStream &strm,
			CORBA::Principal_ptr principal,
			const char *oper,
			void *priv_data);
	
	static void _bounce(void *obj,
			CORBA::MarshalStream &strm,
			CORBA::Principal_ptr principal,
			const char *oper,
			void *priv_data);
	
};
template <class T>
class _tie_StringReciever : public StringReciever
{
    public:
	_tie_StringReciever(T& t, const char *obj_name=(char*)NULL) : 
			StringReciever(obj_name), 
			_ref(t) {
		_object_name(obj_name);
	}
	_tie_StringReciever(T& t, const char *service_name,
			const CORBA::ReferenceData& id)
			:_ref(t) {
		_service(service_name, id);
	}
	~_tie_StringReciever() {}
	void recieveString(const char * arg0) {
		_ref.recieveString(
		arg0);
	}
	void bounce(CORBA::Long arg0) {
		_ref.bounce(
		arg0);
	}

    private:
	T& _ref;
};
class _sk_TestInterface : public TestInterface
{
    protected:
	_sk_TestInterface(const char *object_name = (const char *)NULL);
	_sk_TestInterface(const char *service_name, const CORBA::ReferenceData& data);
	virtual ~_sk_TestInterface() {}
    public:
	static const CORBA::TypeInfo _skel_info;

	// The following operations need to be implemented by the server.
	virtual char * getFirstAppInList() = 0;
	virtual void getAppNames(StringReciever_ptr arg0) = 0;
	virtual TestInterface::sequence_of_Thing * getThings() = 0;
	virtual void callBounce(StringReciever_ptr arg0,
			CORBA::Long arg1) = 0;
	
	// Skeleton Operations implemented automatically
	
	static void _getFirstAppInList(void *obj,
			CORBA::MarshalStream &strm,
			CORBA::Principal_ptr principal,
			const char *oper,
			void *priv_data);
	
	static void _getAppNames(void *obj,
			CORBA::MarshalStream &strm,
			CORBA::Principal_ptr principal,
			const char *oper,
			void *priv_data);
	
	static void _getThings(void *obj,
			CORBA::MarshalStream &strm,
			CORBA::Principal_ptr principal,
			const char *oper,
			void *priv_data);
	
	static void _callBounce(void *obj,
			CORBA::MarshalStream &strm,
			CORBA::Principal_ptr principal,
			const char *oper,
			void *priv_data);
	
};
template <class T>
class _tie_TestInterface : public TestInterface
{
    public:
	_tie_TestInterface(T& t, const char *obj_name=(char*)NULL) : 
			TestInterface(obj_name), 
			_ref(t) {
		_object_name(obj_name);
	}
	_tie_TestInterface(T& t, const char *service_name,
			const CORBA::ReferenceData& id)
			:_ref(t) {
		_service(service_name, id);
	}
	~_tie_TestInterface() {}
	char * getFirstAppInList() {
		return _ref.getFirstAppInList();
	}
	void getAppNames(StringReciever_ptr arg0) {
		_ref.getAppNames(
		arg0);
	}
	TestInterface::sequence_of_Thing * getThings() {
		return _ref.getThings();
	}
	void callBounce(StringReciever_ptr arg0,
		CORBA::Long arg1) {
		_ref.callBounce(
		arg0,
		arg1);
	}

    private:
	T& _ref;
};
class _sk_ISourceTextProvider : public ISourceTextProvider
{
    protected:
	_sk_ISourceTextProvider(const char *object_name = (const char *)NULL);
	_sk_ISourceTextProvider(const char *service_name, const CORBA::ReferenceData& data);
	virtual ~_sk_ISourceTextProvider() {}
    public:
	static const CORBA::TypeInfo _skel_info;

	// The following operations need to be implemented by the server.
	virtual ISourceTextProvider::sequence_of_string * getAllPages() = 0;
	virtual void refreshAllPages() = 0;
	virtual CORBA::Boolean hasPage(const char * arg0) = 0;
	virtual CORBA::Boolean loadPage(const char * arg0) = 0;
	virtual void refreshPage(const char * arg0) = 0;
	virtual char * getPageText(const char * arg0) = 0;
	virtual CORBA::Long getPageStatus(const char * arg0) = 0;
	virtual CORBA::Long getPageAlterCount(const char * arg0) = 0;
	
	// Skeleton Operations implemented automatically
	
	static void _getAllPages(void *obj,
			CORBA::MarshalStream &strm,
			CORBA::Principal_ptr principal,
			const char *oper,
			void *priv_data);
	
	static void _refreshAllPages(void *obj,
			CORBA::MarshalStream &strm,
			CORBA::Principal_ptr principal,
			const char *oper,
			void *priv_data);
	
	static void _hasPage(void *obj,
			CORBA::MarshalStream &strm,
			CORBA::Principal_ptr principal,
			const char *oper,
			void *priv_data);
	
	static void _loadPage(void *obj,
			CORBA::MarshalStream &strm,
			CORBA::Principal_ptr principal,
			const char *oper,
			void *priv_data);
	
	static void _refreshPage(void *obj,
			CORBA::MarshalStream &strm,
			CORBA::Principal_ptr principal,
			const char *oper,
			void *priv_data);
	
	static void _getPageText(void *obj,
			CORBA::MarshalStream &strm,
			CORBA::Principal_ptr principal,
			const char *oper,
			void *priv_data);
	
	static void _getPageStatus(void *obj,
			CORBA::MarshalStream &strm,
			CORBA::Principal_ptr principal,
			const char *oper,
			void *priv_data);
	
	static void _getPageAlterCount(void *obj,
			CORBA::MarshalStream &strm,
			CORBA::Principal_ptr principal,
			const char *oper,
			void *priv_data);
	
};
template <class T>
class _tie_ISourceTextProvider : public ISourceTextProvider
{
    public:
	_tie_ISourceTextProvider(T& t, const char *obj_name=(char*)NULL) : 
			ISourceTextProvider(obj_name), 
			_ref(t) {
		_object_name(obj_name);
	}
	_tie_ISourceTextProvider(T& t, const char *service_name,
			const CORBA::ReferenceData& id)
			:_ref(t) {
		_service(service_name, id);
	}
	~_tie_ISourceTextProvider() {}
	ISourceTextProvider::sequence_of_string * getAllPages() {
		return _ref.getAllPages();
	}
	void refreshAllPages() {
		_ref.refreshAllPages();
	}
	CORBA::Boolean hasPage(const char * arg0) {
		return _ref.hasPage(
		arg0);
	}
	CORBA::Boolean loadPage(const char * arg0) {
		return _ref.loadPage(
		arg0);
	}
	void refreshPage(const char * arg0) {
		_ref.refreshPage(
		arg0);
	}
	char * getPageText(const char * arg0) {
		return _ref.getPageText(
		arg0);
	}
	CORBA::Long getPageStatus(const char * arg0) {
		return _ref.getPageStatus(
		arg0);
	}
	CORBA::Long getPageAlterCount(const char * arg0) {
		return _ref.getPageAlterCount(
		arg0);
	}

    private:
	T& _ref;
};
class _sk_IJSErrorReporter : public IJSErrorReporter
{
    protected:
	_sk_IJSErrorReporter(const char *object_name = (const char *)NULL);
	_sk_IJSErrorReporter(const char *service_name, const CORBA::ReferenceData& data);
	virtual ~_sk_IJSErrorReporter() {}
    public:
	static const CORBA::TypeInfo _skel_info;

	// The following operations need to be implemented by the server.
	virtual CORBA::Long reportError(const char * arg0,
			const char * arg1,
			CORBA::Long arg2,
			const char * arg3,
			CORBA::Long arg4) = 0;
	
	// Skeleton Operations implemented automatically
	
	static void _reportError(void *obj,
			CORBA::MarshalStream &strm,
			CORBA::Principal_ptr principal,
			const char *oper,
			void *priv_data);
	
};
template <class T>
class _tie_IJSErrorReporter : public IJSErrorReporter
{
    public:
	_tie_IJSErrorReporter(T& t, const char *obj_name=(char*)NULL) : 
			IJSErrorReporter(obj_name), 
			_ref(t) {
		_object_name(obj_name);
	}
	_tie_IJSErrorReporter(T& t, const char *service_name,
			const CORBA::ReferenceData& id)
			:_ref(t) {
		_service(service_name, id);
	}
	~_tie_IJSErrorReporter() {}
	CORBA::Long reportError(const char * arg0,
		const char * arg1,
		CORBA::Long arg2,
		const char * arg3,
		CORBA::Long arg4) {
		return _ref.reportError(
		arg0,
		arg1,
		arg2,
		arg3,
		arg4);
	}

    private:
	T& _ref;
};
class _sk_IScriptHook : public IScriptHook
{
    protected:
	_sk_IScriptHook(const char *object_name = (const char *)NULL);
	_sk_IScriptHook(const char *service_name, const CORBA::ReferenceData& data);
	virtual ~_sk_IScriptHook() {}
    public:
	static const CORBA::TypeInfo _skel_info;

	// The following operations need to be implemented by the server.
	virtual void justLoadedScript(const IScript& arg0) = 0;
	virtual void aboutToUnloadScript(const IScript& arg0) = 0;
	
	// Skeleton Operations implemented automatically
	
	static void _justLoadedScript(void *obj,
			CORBA::MarshalStream &strm,
			CORBA::Principal_ptr principal,
			const char *oper,
			void *priv_data);
	
	static void _aboutToUnloadScript(void *obj,
			CORBA::MarshalStream &strm,
			CORBA::Principal_ptr principal,
			const char *oper,
			void *priv_data);
	
};
template <class T>
class _tie_IScriptHook : public IScriptHook
{
    public:
	_tie_IScriptHook(T& t, const char *obj_name=(char*)NULL) : 
			IScriptHook(obj_name), 
			_ref(t) {
		_object_name(obj_name);
	}
	_tie_IScriptHook(T& t, const char *service_name,
			const CORBA::ReferenceData& id)
			:_ref(t) {
		_service(service_name, id);
	}
	~_tie_IScriptHook() {}
	void justLoadedScript(const IScript& arg0) {
		_ref.justLoadedScript(
		arg0);
	}
	void aboutToUnloadScript(const IScript& arg0) {
		_ref.aboutToUnloadScript(
		arg0);
	}

    private:
	T& _ref;
};
class _sk_IJSExecutionHook : public IJSExecutionHook
{
    protected:
	_sk_IJSExecutionHook(const char *object_name = (const char *)NULL);
	_sk_IJSExecutionHook(const char *service_name, const CORBA::ReferenceData& data);
	virtual ~_sk_IJSExecutionHook() {}
    public:
	static const CORBA::TypeInfo _skel_info;

	// The following operations need to be implemented by the server.
	virtual void aboutToExecute(const IJSThreadState& arg0,
			const IJSPC& arg1) = 0;
	
	// Skeleton Operations implemented automatically
	
	static void _aboutToExecute(void *obj,
			CORBA::MarshalStream &strm,
			CORBA::Principal_ptr principal,
			const char *oper,
			void *priv_data);
	
};
template <class T>
class _tie_IJSExecutionHook : public IJSExecutionHook
{
    public:
	_tie_IJSExecutionHook(T& t, const char *obj_name=(char*)NULL) : 
			IJSExecutionHook(obj_name), 
			_ref(t) {
		_object_name(obj_name);
	}
	_tie_IJSExecutionHook(T& t, const char *service_name,
			const CORBA::ReferenceData& id)
			:_ref(t) {
		_service(service_name, id);
	}
	~_tie_IJSExecutionHook() {}
	void aboutToExecute(const IJSThreadState& arg0,
		const IJSPC& arg1) {
		_ref.aboutToExecute(
		arg0,
		arg1);
	}

    private:
	T& _ref;
};
class _sk_IDebugController : public IDebugController
{
    protected:
	_sk_IDebugController(const char *object_name = (const char *)NULL);
	_sk_IDebugController(const char *service_name, const CORBA::ReferenceData& data);
	virtual ~_sk_IDebugController() {}
    public:
	static const CORBA::TypeInfo _skel_info;

	// The following operations need to be implemented by the server.
	virtual CORBA::Long getMajorVersion() = 0;
	virtual CORBA::Long getMinorVersion() = 0;
	virtual IJSErrorReporter_ptr setErrorReporter(IJSErrorReporter_ptr arg0) = 0;
	virtual IJSErrorReporter_ptr getErrorReporter() = 0;
	virtual IScriptHook_ptr setScriptHook(IScriptHook_ptr arg0) = 0;
	virtual IScriptHook_ptr getScriptHook() = 0;
	virtual IJSPC * getClosestPC(const IScript& arg0,
			CORBA::Long arg1) = 0;
	virtual IJSSourceLocation * getSourceLocation(const IJSPC& arg0) = 0;
	virtual IJSExecutionHook_ptr setInterruptHook(IJSExecutionHook_ptr arg0) = 0;
	virtual IJSExecutionHook_ptr getInterruptHook() = 0;
	virtual IJSExecutionHook_ptr setDebugBreakHook(IJSExecutionHook_ptr arg0) = 0;
	virtual IJSExecutionHook_ptr getDebugBreakHook() = 0;
	virtual IJSExecutionHook_ptr setInstructionHook(IJSExecutionHook_ptr arg0,
			const IJSPC& arg1) = 0;
	virtual IJSExecutionHook_ptr getInstructionHook(const IJSPC& arg0) = 0;
	virtual void setThreadContinueState(CORBA::Long arg0,
			CORBA::Long arg1) = 0;
	virtual void setThreadReturnValue(CORBA::Long arg0,
			const char * arg1) = 0;
	virtual void sendInterrupt() = 0;
	virtual void sendInterruptStepInto(CORBA::Long arg0) = 0;
	virtual void sendInterruptStepOver(CORBA::Long arg0) = 0;
	virtual void sendInterruptStepOut(CORBA::Long arg0) = 0;
	virtual void reinstateStepper(CORBA::Long arg0) = 0;
	virtual IExecResult * executeScriptInStackFrame(CORBA::Long arg0,
			const IJSStackFrameInfo& arg1,
			const char * arg2,
			const char * arg3,
			CORBA::Long arg4) = 0;
	virtual CORBA::Boolean isRunningHook(CORBA::Long arg0) = 0;
	virtual CORBA::Boolean isWaitingForResume(CORBA::Long arg0) = 0;
	virtual void leaveThreadSuspended(CORBA::Long arg0) = 0;
	virtual void resumeThread(CORBA::Long arg0) = 0;
	virtual void iterateScripts(IScriptHook_ptr arg0) = 0;
	
	// Skeleton Operations implemented automatically
	
	static void _getMajorVersion(void *obj,
			CORBA::MarshalStream &strm,
			CORBA::Principal_ptr principal,
			const char *oper,
			void *priv_data);
	
	static void _getMinorVersion(void *obj,
			CORBA::MarshalStream &strm,
			CORBA::Principal_ptr principal,
			const char *oper,
			void *priv_data);
	
	static void _setErrorReporter(void *obj,
			CORBA::MarshalStream &strm,
			CORBA::Principal_ptr principal,
			const char *oper,
			void *priv_data);
	
	static void _getErrorReporter(void *obj,
			CORBA::MarshalStream &strm,
			CORBA::Principal_ptr principal,
			const char *oper,
			void *priv_data);
	
	static void _setScriptHook(void *obj,
			CORBA::MarshalStream &strm,
			CORBA::Principal_ptr principal,
			const char *oper,
			void *priv_data);
	
	static void _getScriptHook(void *obj,
			CORBA::MarshalStream &strm,
			CORBA::Principal_ptr principal,
			const char *oper,
			void *priv_data);
	
	static void _getClosestPC(void *obj,
			CORBA::MarshalStream &strm,
			CORBA::Principal_ptr principal,
			const char *oper,
			void *priv_data);
	
	static void _getSourceLocation(void *obj,
			CORBA::MarshalStream &strm,
			CORBA::Principal_ptr principal,
			const char *oper,
			void *priv_data);
	
	static void _setInterruptHook(void *obj,
			CORBA::MarshalStream &strm,
			CORBA::Principal_ptr principal,
			const char *oper,
			void *priv_data);
	
	static void _getInterruptHook(void *obj,
			CORBA::MarshalStream &strm,
			CORBA::Principal_ptr principal,
			const char *oper,
			void *priv_data);
	
	static void _setDebugBreakHook(void *obj,
			CORBA::MarshalStream &strm,
			CORBA::Principal_ptr principal,
			const char *oper,
			void *priv_data);
	
	static void _getDebugBreakHook(void *obj,
			CORBA::MarshalStream &strm,
			CORBA::Principal_ptr principal,
			const char *oper,
			void *priv_data);
	
	static void _setInstructionHook(void *obj,
			CORBA::MarshalStream &strm,
			CORBA::Principal_ptr principal,
			const char *oper,
			void *priv_data);
	
	static void _getInstructionHook(void *obj,
			CORBA::MarshalStream &strm,
			CORBA::Principal_ptr principal,
			const char *oper,
			void *priv_data);
	
	static void _setThreadContinueState(void *obj,
			CORBA::MarshalStream &strm,
			CORBA::Principal_ptr principal,
			const char *oper,
			void *priv_data);
	
	static void _setThreadReturnValue(void *obj,
			CORBA::MarshalStream &strm,
			CORBA::Principal_ptr principal,
			const char *oper,
			void *priv_data);
	
	static void _sendInterrupt(void *obj,
			CORBA::MarshalStream &strm,
			CORBA::Principal_ptr principal,
			const char *oper,
			void *priv_data);
	
	static void _sendInterruptStepInto(void *obj,
			CORBA::MarshalStream &strm,
			CORBA::Principal_ptr principal,
			const char *oper,
			void *priv_data);
	
	static void _sendInterruptStepOver(void *obj,
			CORBA::MarshalStream &strm,
			CORBA::Principal_ptr principal,
			const char *oper,
			void *priv_data);
	
	static void _sendInterruptStepOut(void *obj,
			CORBA::MarshalStream &strm,
			CORBA::Principal_ptr principal,
			const char *oper,
			void *priv_data);
	
	static void _reinstateStepper(void *obj,
			CORBA::MarshalStream &strm,
			CORBA::Principal_ptr principal,
			const char *oper,
			void *priv_data);
	
	static void _executeScriptInStackFrame(void *obj,
			CORBA::MarshalStream &strm,
			CORBA::Principal_ptr principal,
			const char *oper,
			void *priv_data);
	
	static void _isRunningHook(void *obj,
			CORBA::MarshalStream &strm,
			CORBA::Principal_ptr principal,
			const char *oper,
			void *priv_data);
	
	static void _isWaitingForResume(void *obj,
			CORBA::MarshalStream &strm,
			CORBA::Principal_ptr principal,
			const char *oper,
			void *priv_data);
	
	static void _leaveThreadSuspended(void *obj,
			CORBA::MarshalStream &strm,
			CORBA::Principal_ptr principal,
			const char *oper,
			void *priv_data);
	
	static void _resumeThread(void *obj,
			CORBA::MarshalStream &strm,
			CORBA::Principal_ptr principal,
			const char *oper,
			void *priv_data);
	
	static void _iterateScripts(void *obj,
			CORBA::MarshalStream &strm,
			CORBA::Principal_ptr principal,
			const char *oper,
			void *priv_data);
	
};
template <class T>
class _tie_IDebugController : public IDebugController
{
    public:
	_tie_IDebugController(T& t, const char *obj_name=(char*)NULL) : 
			IDebugController(obj_name), 
			_ref(t) {
		_object_name(obj_name);
	}
	_tie_IDebugController(T& t, const char *service_name,
			const CORBA::ReferenceData& id)
			:_ref(t) {
		_service(service_name, id);
	}
	~_tie_IDebugController() {}
	CORBA::Long getMajorVersion() {
		return _ref.getMajorVersion();
	}
	CORBA::Long getMinorVersion() {
		return _ref.getMinorVersion();
	}
	IJSErrorReporter_ptr setErrorReporter(IJSErrorReporter_ptr arg0) {
		return _ref.setErrorReporter(
		arg0);
	}
	IJSErrorReporter_ptr getErrorReporter() {
		return _ref.getErrorReporter();
	}
	IScriptHook_ptr setScriptHook(IScriptHook_ptr arg0) {
		return _ref.setScriptHook(
		arg0);
	}
	IScriptHook_ptr getScriptHook() {
		return _ref.getScriptHook();
	}
	IJSPC * getClosestPC(const IScript& arg0,
		CORBA::Long arg1) {
		return _ref.getClosestPC(
		arg0,
		arg1);
	}
	IJSSourceLocation * getSourceLocation(const IJSPC& arg0) {
		return _ref.getSourceLocation(
		arg0);
	}
	IJSExecutionHook_ptr setInterruptHook(IJSExecutionHook_ptr arg0) {
		return _ref.setInterruptHook(
		arg0);
	}
	IJSExecutionHook_ptr getInterruptHook() {
		return _ref.getInterruptHook();
	}
	IJSExecutionHook_ptr setDebugBreakHook(IJSExecutionHook_ptr arg0) {
		return _ref.setDebugBreakHook(
		arg0);
	}
	IJSExecutionHook_ptr getDebugBreakHook() {
		return _ref.getDebugBreakHook();
	}
	IJSExecutionHook_ptr setInstructionHook(IJSExecutionHook_ptr arg0,
		const IJSPC& arg1) {
		return _ref.setInstructionHook(
		arg0,
		arg1);
	}
	IJSExecutionHook_ptr getInstructionHook(const IJSPC& arg0) {
		return _ref.getInstructionHook(
		arg0);
	}
	void setThreadContinueState(CORBA::Long arg0,
		CORBA::Long arg1) {
		_ref.setThreadContinueState(
		arg0,
		arg1);
	}
	void setThreadReturnValue(CORBA::Long arg0,
		const char * arg1) {
		_ref.setThreadReturnValue(
		arg0,
		arg1);
	}
	void sendInterrupt() {
		_ref.sendInterrupt();
	}
	void sendInterruptStepInto(CORBA::Long arg0) {
		_ref.sendInterruptStepInto(
		arg0);
	}
	void sendInterruptStepOver(CORBA::Long arg0) {
		_ref.sendInterruptStepOver(
		arg0);
	}
	void sendInterruptStepOut(CORBA::Long arg0) {
		_ref.sendInterruptStepOut(
		arg0);
	}
	void reinstateStepper(CORBA::Long arg0) {
		_ref.reinstateStepper(
		arg0);
	}
	IExecResult * executeScriptInStackFrame(CORBA::Long arg0,
		const IJSStackFrameInfo& arg1,
		const char * arg2,
		const char * arg3,
		CORBA::Long arg4) {
		return _ref.executeScriptInStackFrame(
		arg0,
		arg1,
		arg2,
		arg3,
		arg4);
	}
	CORBA::Boolean isRunningHook(CORBA::Long arg0) {
		return _ref.isRunningHook(
		arg0);
	}
	CORBA::Boolean isWaitingForResume(CORBA::Long arg0) {
		return _ref.isWaitingForResume(
		arg0);
	}
	void leaveThreadSuspended(CORBA::Long arg0) {
		_ref.leaveThreadSuspended(
		arg0);
	}
	void resumeThread(CORBA::Long arg0) {
		_ref.resumeThread(
		arg0);
	}
	void iterateScripts(IScriptHook_ptr arg0) {
		_ref.iterateScripts(
		arg0);
	}

    private:
	T& _ref;
};

#endif

